{"mappings":"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","sources":["src/Scene.ts","src/Library.ts","src/Clip.ts","src/Drawable.ts","src/Layer.ts","src/Frame.ts","src/ClipInstance.ts","src/geom/Vec2.ts","src/Instance.ts","src/geom/Matrix.ts","src/util/math.ts","src/SpriteInstance.ts","src/Sprite.ts","src/Atlas.ts","src/json/utilJson.ts","src/util/createImage.ts"],"sourcesContent":["import { Drawable } from \"./Drawable\";\nimport { Library } from \"./Library\";\nimport { Float } from \"./types/Float\";\n\n\nexport class Scene{\n\n    draw: (item:Drawable, frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void) => void\n    drawImage: (image:HTMLImageElement, sx:number, sy:number, sw:number, sh:number, rx:number, ry:number, rw:number, rh:number) => void\n    pixelData:Record<string, { ctx:CanvasRenderingContext2D, imageData:ImageData, image:HTMLImageElement }>\n\n\n    constructor(){\n        this.draw = null! // OVERRIDE THIS IN THE BASE CLASS!\n        this.drawImage = null!\n        this.pixelData = {}\n    }\n\n\n    get mouseX():number{\n        throw(\"Override mouseX in base class\")\n    }\n\n\n    get mouseY():number{\n        throw(\"Override mouseY in base class\")\n    }\n\n  \n    createLibrary(name:string, path:string){\n        const library = new Library(name, path, this);\n        return library;\n    }\n\n\n    getPixelData(image:HTMLImageElement){\n        if(image.complete==false) throw(\"Image has not loaded!\")\n\n        const canvas = document.createElement('canvas')\n        canvas.width = image.width\n        canvas.height = image.height\n        const ctx = document.createElement('canvas').getContext('2d')!\n        ctx.drawImage(image, 0, 0);\n\n        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)\n\n        return {\n            ctx,\n            imageData,\n            image,\n        }\n    }\n\n\n}","import { JsonAnimationData } from \"./json/AnimationJson\";\nimport { Clip, ClipProps } from \"./Clip\";\nimport { Vec2 } from \"./geom/Vec2\";\nimport { InstanceProps } from \"./Instance\";\nimport { Sprite, SpriteProps } from \"./Sprite\";\nimport { Atlas, AtlasProps } from \"./Atlas\";\nimport { normaliseJson } from \"./json/utilJson\";\nimport { Scene } from \"./Scene\";\nimport { Matrix } from \"./geom/Matrix\";\nimport { JsonSpriteMap } from \"./json/SpritemapJson\"\nimport { createImage } from \"./util/createImage\";\n\n\nexport class Library{\n\n    name:string;\n    path:string;\n    clips:Array<Clip> = [];\n    clipsByName:Record<string, Clip> = {};\n    spritesByName:Record<string, Sprite> = {};\n    atlases:Array<Atlas> = [];\n    atlasesBySpriteName:Record<string, Atlas> = {}\n    scene:Scene;\n    \n    \n    constructor(name:string, path:string, scene:Scene){\n        this.name = name;\n        this.path = path;\n        this.atlases = [];\n        this.scene = scene;\n    }\n\n\n    symbol(name:string){\n        if(this.clipsByName[name]) return this.clipsByName[name]\n        if(this.spritesByName[name]) return this.spritesByName[name]\n        throw(\"Cannot find symbol: \" + name + \" for library: \" + this.path);\n    }\n\n\n    createAtlas(props:Omit<AtlasProps, 'library'|'pixelData'>, pixelData:ReturnType<Scene['getPixelData']>){\n        const atlas = new Atlas({...props, library:this, pixelData});\n        this.atlases.push(atlas);\n        return atlas;\n    }\n\n\n    createSprite(atlas:Atlas, props:Omit<SpriteProps, 'atlas'>){\n        const sprite = new Sprite({...props, atlas:atlas})\n        atlas.sprites.push(sprite);\n        this.spritesByName[sprite.name] = sprite;\n        this.atlasesBySpriteName[sprite.name] = atlas;\n        return sprite;\n    }\n\n\n    createClip(props:Omit<ClipProps, 'library'>){\n        const clip = new Clip({...props, library:this});\n        this.clips.push(clip)\n        this.clipsByName[clip.name] = clip\n        return clip;\n    }\n\n\n    public async loadData(){\n        const animJsonPath = this.path + \"/Animation.json\";\n        const animFetchResult = await fetch(animJsonPath);\n        const dataRaw:JsonAnimationData = await animFetchResult.json();\n        const data = normaliseJson(dataRaw) as JsonAnimationData;\n        const spriteNames:Array<string> = [];\n\n        // Clip\n        for(const symbolData of data.symbolDictionary.symbols){\n            const clip = this.createClip({\n                name: symbolData.symbolName,\n            })\n\n            // Layer\n            for(let l=symbolData.timeline.layers.length-1; l>=0; l--){\n                const layerData = symbolData.timeline.layers[l]\n                const layer = clip.createLayer({\n                    name: layerData.layerName,\n                    type: layerData.layerType || 'Normal',\n                    clippedBy: layerData.clippedBy || null,\n                })\n\n                // Frame\n                for(const frameData of layerData.frames){\n                    const frame = layer.createFrame({\n                        name: \"\"+frameData.index,\n                        totalFrames: frameData.duration,\n                        labelName: frameData.name,\n                        index: frameData.index,\n                    })\n\n                    // Element\n                    for(const elemInstanceData of  frameData.elements){\n                        if(\"symbolInstance\" in elemInstanceData){\n                            const elemData = elemInstanceData.symbolInstance;\n                            const m = elemData.matrix3D;\n\n                            const instanceProps:Omit<InstanceProps, 'totalFrames'>  = {\n                                frame,\n                                name: frame.name,\n                                filters: elemData.filters || null,\n                                matrix: 'm00' in m ? new Matrix(m.m00, m.m01, m.m02, m.m03,\n                                                                    m.m10, m.m11, m.m12, m.m13,\n                                                                    m.m20, m.m21, m.m22, m.m23,\n                                                                    m.m30, m.m31, m.m32, m.m33)\n                                                     : new Matrix(m[ 0], m[ 1], m[ 2], m[ 3],\n                                                                    m[ 4], m[ 5], m[ 6], m[ 7],\n                                                                    m[ 8], m[ 9], m[10], m[11],\n                                                                    m[12], m[13], m[14], m[15]),\n                                itemName: elemData.symbolName,\n                                color: elemData.color || null,\n                                //position: new Vec3(elemData.decomposedMatrix.position),\n                                //scale: new Vec3(elemData.decomposedMatrix.scaling),\n                                //rotation: new Vec3(elemData.decomposedMatrix.rotation),\n                            }\n\n                            const clipInstance = frame.createClipInstance({\n                                ...instanceProps,\n                                transformationPoint: new Vec2(elemData.transformationPoint),\n                                behaviour: elemData.symbolType == \"graphic\"\n                                         ? { type: 'graphic', loop: elemData.loop, firstFrame: elemData.firstFrame}\n                                         : { type: 'movieclip' }\n                            })\n                        }else{\n                            const elemData = elemInstanceData.atlasSpriteInstance;\n                            const m = elemData.matrix3D;\n\n                            const spriteInstance = frame.createSpriteInstance({\n                                name: frame.name,\n                                filters: elemData.filters || null,\n                                color: null,\n                                matrix: 'm00' in m ? new Matrix(m.m00, m.m01, m.m02, m.m03,\n                                                                    m.m10, m.m11, m.m12, m.m13,\n                                                                    m.m20, m.m21, m.m22, m.m23,\n                                                                    m.m30, m.m31, m.m32, m.m33)\n                                                     : new Matrix(m[ 0], m[ 1], m[ 2], m[ 3],\n                                                                    m[ 4], m[ 5], m[ 6], m[ 7],\n                                                                    m[ 8], m[ 9], m[10], m[11],\n                                                                    m[12], m[13], m[14], m[15]),\n                                itemName: elemData.name,\n                                //position: new Vec3(elemData.decomposedMatrix.position),\n                                //scale: new Vec3(elemData.decomposedMatrix.scaling),\n                                //rotation: new Vec3(elemData.decomposedMatrix.rotation),\n                            })\n\n                            if(spriteNames.indexOf(spriteInstance.itemName)==-1) spriteNames.push(spriteInstance.itemName)\n                        }\n                    }\n                }\n            }\n        };\n\n        // Sprites\n        let pendingAtlasIndex = 1;\n        for(const spriteName of spriteNames){\n            if(this.atlasesBySpriteName[spriteName]==null){\n                const spriteJsonPath = this.path + `/spritemap${pendingAtlasIndex}.json`;\n                const altasFetch = await fetch(spriteJsonPath);\n                const dataRaw:JsonSpriteMap = await altasFetch.json();\n                const data = normaliseJson(dataRaw) as JsonSpriteMap;\n\n                const imagePath = this.path + `/spritemap${pendingAtlasIndex}.png`;\n                const image = await createImage(imagePath) // TODO: This will impact load times. Find a way to make this load parallel. Workers?\n\n                \n                const atlas = this.createAtlas({\n                    image,\n                    app: data.meta.app,\n                    version: data.meta.version,\n                    imagePath: data.meta.image,\n                    format: data.meta.format,\n                    size: data.meta.size,\n                    resolution: data.meta.resolution ,\n                }, this.scene.getPixelData(image),)\n                for(const spriteSpriteData of data.atlas.sprites){\n                    const spriteData = spriteSpriteData.sprite;\n                    const sprite = this.createSprite(atlas, {\n                        name: spriteData.name,\n                        x: spriteData.x,\n                        y: spriteData.y,\n                        width: spriteData.w,\n                        height: spriteData.h,\n                        rotated: spriteData.rotated,\n                    })\n                    this.atlasesBySpriteName[sprite.name] = atlas;\n                }\n\n\n                pendingAtlasIndex++;\n            }\n        }\n\n    }\n\n\n}\n","import { Drawable } from \"./Drawable\";\nimport { Frame } from \"./Frame\";\nimport { Layer, LayerProps } from \"./Layer\";\nimport { DrawableProps } from './Drawable'\nimport { modWrap } from \"./util/math\";\nimport { Float } from \"./types/Float\";\n\nexport type ClipProps = Omit<DrawableProps, 'totalFrames'|'id'>\n\n\nexport class Clip extends Drawable{\n\n    layers:Array<Layer>;\n    layersById:Record<string, Layer>;\n    layersByName:Record<string, Layer>\n    framesById:Record<string, Frame>\n    framesByLabel:Record<string, Frame>\n\n\n    constructor(props:ClipProps){\n        super({\n            ...props,\n            totalFrames:0,\n            id:`${props.library.name}.clips.${props.name}`,\n        })\n        \n        this.layers = [];\n        this.layersById = {};\n        this.layersByName = {};\n        this.framesById = {};\n        this.framesByLabel = {};\n    }\n\n\n    public createLayer(props:Omit<LayerProps, 'clip'>){\n        const layer = new Layer({...props, clip:this});\n        this.layers.push(layer);\n        this.layersById[layer.id] = layer;\n        this.layersByName[layer.name] = layer;\n        if(layer.totalFrames > this.totalFrames) this.totalFrames = layer.totalFrames;\n\n        return layer;\n    }\n\n\n    __addFrame(frame:Frame){\n        this.framesById[frame.id] = frame;\n        if(frame.layer.totalFrames > this.totalFrames) this.totalFrames = frame.layer.totalFrames;\n        if(frame.labelName) this.framesByLabel[frame.labelName] = frame;\n    }\n\n\n    public draw(frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void){\n        for(const layer of this.layers){\n            if(layer.totalFrames==0) continue;\n            var f = modWrap(frame, layer.totalFrames);\n            if(layer.totalFrames>=f){\n                this.library.scene.draw(layer, frame, lerp, callback);\n            }\n        }\n    }\n\n   \n}","import { Library } from \"./Library\";\nimport { Float } from \"./types/Float\";\nimport { Int } from \"./types/Int\";\n\n\nexport type DrawableProps = {\n    name:string,\n    id:string,\n    totalFrames:Int,\n    library:Library;\n}\n\n\nexport abstract class Drawable{\n    name:string;\n    id:string;\n    totalFrames:Int = 1;\n    library:Library;\n\n\n    constructor(props:DrawableProps){\n        this.name = props.name;\n        this.id = props.id;\n        this.totalFrames = props.totalFrames;\n        this.library = props.library;\n    }\n\n\n    public get scene(){\n        return this.library.scene;\n    }\n\n\n    public draw(frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void){\n        // Override in base class\n    }\n\n}","import { Clip } from \"./Clip\";\nimport { Drawable } from \"./Drawable\";\nimport { Frame, FrameProps } from \"./Frame\";\nimport { DrawableProps } from \"./Drawable\"\nimport { modWrap } from \"./util/math\";\nimport { Int } from \"./types/Int\";\nimport { Float } from \"./types/Float\";\n\n\n\nexport type LayerProps = Omit<DrawableProps, 'totalFrames'|'id'|'library'> & {\n    clip:Clip\n    type: 'Normal'|'Clipper',\n    clippedBy?:string|null,\n}\n\n\nexport class Layer extends Drawable{\n\n    public index:Int;\n    public type: LayerProps['type'];\n    public clippedBy:string|null;\n    public frames:Array<Frame>;\n    public framesByName:Record<string, Frame>;\n    public labels:Array<Frame>;\n    public clip:Clip;\n\n\n    constructor(props:LayerProps){\n        super({\n            ...props,\n            totalFrames:0,\n            id:`${props.clip.id}.${props.name}`,\n            library: props.clip.library,\n        });\n        \n        this.clip = props.clip;\n        this.type = props.type;\n        this.clippedBy = props.clippedBy || null;\n        this.index = this.clip.layers.length;\n        this.frames = [];\n        this.framesByName = {};\n        this.labels = [];\n    }\n\n\n    public createFrame(props:Omit<FrameProps, 'layer'>){\n        const frame = new Frame({...props, layer:this});\n\n        // TODO: Allow for more flexibility when adding frames\n        if(this.frames.length>0 && this.lastFrame.index+this.lastFrame.totalFrames != frame.index) throw(\"Must add next frame at previous frame.index+frame.duration\")\n\n        this.framesByName[frame.name] = frame;\n        if(frame.index+frame.totalFrames > this.totalFrames) this.totalFrames = frame.index+frame.totalFrames\n        if(frame.labelName){\n            this.labels.push(frame);\n        }\n        this.clip.__addFrame(frame);\n        /* TODO: Determine if this should be nessessary\n        if(this.firstFrame){\n            this.firstFrame.prev = frame\n            frame.next = this.firstFrame\n        }\n        */\n        if(this.lastFrame){\n            this.lastFrame.next = frame\n            frame.prev = this.lastFrame\n        }\n        this.frames.push(frame)\n        return frame;\n    }\n\n\n    public get lastFrame(){\n        return this.frames[this.frames.length-1];\n    }\n\n\n    public get firstFrame(){\n        return this.frames[0];\n    }\n\n\n    public keyframeAt(frame:Float){\n        // TODO: Binary search would be a good optimisation here\n        frame = modWrap(frame, this.totalFrames);\n        for(const keyframe of this.frames){\n            if(keyframe.index<=frame && keyframe.index+keyframe.totalFrames > frame)\n            return keyframe;\n        }\n        return null;\n    }\n\n\n    public draw(frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void):void{\n        var keyframe = this.keyframeAt(frame)\n        if(keyframe!=null){\n            this.library.scene.draw(keyframe, frame, lerp, callback);\n        }\n    }\n\n}\n","import { ClipInstance, ClipInstanceProps } from \"./ClipInstance\";\nimport { Drawable } from \"./Drawable\";\nimport { Layer } from \"./Layer\";\nimport { SpriteInstance, SpriteInstanceProps } from \"./SpriteInstance\";\nimport { DrawableProps } from \"./Drawable\";\nimport { Int } from \"./types/Int\";\nimport { Float } from \"./types/Float\";\n\n\n\nexport type FrameProps = Omit<DrawableProps, 'id' | 'library'> & {\n    index:Int,\n    layer:Layer,\n    labelName?:string|undefined|null,\n}\n\n\nexport class Frame extends Drawable{\n\n    index:number\n    labelName:string|null;\n    layer:Layer;\n    instances:Array<ClipInstance|SpriteInstance> = [];\n    prev:Frame|undefined;\n    next:Frame|undefined;\n\n\n    constructor(props:FrameProps){\n        super({\n            ...props,\n            id: `${props.layer.id}.${props.index}`,\n            library: props.layer.library\n        });\n        \n        this.layer = props.layer;\n        this.index = props.index;\n        this.labelName = props.labelName || null;\n    }\n\n\n    public createClipInstance(props:Omit<ClipInstanceProps, 'frame'|'totalFrames'>){\n        const clipInstance = new ClipInstance({...props, frame:this, totalFrames:this.totalFrames})\n        this.instances.push(clipInstance)\n        return clipInstance;\n    }\n\n\n    public createSpriteInstance(props:Omit<SpriteInstanceProps, 'frame'|'totalFrames'>){\n        const spriteInstance = new SpriteInstance({...props, frame:this, totalFrames:this.totalFrames})\n        this.instances.push(spriteInstance)\n        return spriteInstance\n    }\n\n\n    public draw(frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float)=>void):void{\n        for(const instance of this.instances){\n            this.library.scene.draw(instance, frame, lerp, callback)\n        }\n    }\n\n}\n","import { Drawable } from \"./Drawable\";\nimport { Vec2 } from \"./geom/Vec2\";\nimport { Instance } from \"./Instance\";\nimport { InstanceProps } from \"./Instance\"\nimport { Float } from \"./types/Float\";\nimport { modWrap } from \"./util/math\";\n\ntype LoopKind = 'loop' // TODO: HANDLE OTHER LOOP KINDS | 'PlayOnce' | 'SingleFrame' | 'PlayOnceReverse' | 'LoopReverse'\n\n\ntype ClipInstanceBehavior = {\n    type: 'graphic'\n    loop:LoopKind;\n    firstFrame:Float;\n} | {\n    type: 'movieclip'\n}\n\n\nexport type ClipInstanceProps = InstanceProps & { \n    transformationPoint?:Vec2,   \n    behaviour?:ClipInstanceBehavior\n}\n\n\nexport class ClipInstance extends Instance{\n\n    transformationPoint:Vec2\n    behaviour:ClipInstanceBehavior\n    \n    \n    constructor(props:ClipInstanceProps){\n        super(props);\n        this.behaviour = props.behaviour || { type: 'movieclip' };\n        this.transformationPoint = props.transformationPoint || new Vec2({x:0, y:0});\n    }\n\n\n    public get item(){\n        return this.library.clipsByName[this.itemName];\n    }\n\n\n    public draw(frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void):void{\n        if(this.behaviour.type == 'graphic'){\n            frame = this.behaviour.firstFrame + modWrap(frame, 1);\n        }\n        this.library.scene.draw(this.item, frame, lerp, callback)\n    }\n\n\n}\n","import { Float } from \"../types/Float\"\n\nexport class Vec2 {\n\n    x:Float\n    y:Float\n    data:Float32Array\n\n    \n    constructor(props:{x:Float, y:Float}){\n        this.x = props.x\n        this.y = props.y\n        this.data = new Float32Array([this.x, this.y])\n    }\n    \n}","import { Drawable } from \"./Drawable\";\nimport { Frame } from \"./Frame\";\nimport { DrawableProps } from './Drawable'\nimport { Matrix } from \"./geom/Matrix\";\nimport { JsonColor, JsonFilters } from \"./json/AnimationJson\";\nimport { Float } from \"./types/Float\";\n\n\nexport type InstanceProps = Omit<DrawableProps, 'id' | 'library'> & {\n    itemName:string,\n    matrix?:Matrix,\n    frame:Frame,\n    filters?:JsonFilters|null,\n    color?:JsonColor|null,\n    //position:Vec3,\n    //scale:Vec3,\n    //rotation:Vec3,\n}\n\n\nexport class Instance extends Drawable{\n\n    matrix:Matrix;\n    frame:Frame;\n    index:number;\n    itemName:string;\n    filters:JsonFilters|null;\n    color:JsonColor|null;\n    //position:Vec3;\n    //scale:Vec3;\n    //rotation:Vec3;\n    //filters = new Array<Filter>();\n\n    \n    constructor(props:InstanceProps){\n        super({\n            ...props,\n            library: props.frame.library,\n            id: `${props.frame.id}.${props.frame.instances.length}`,\n        });\n\n        this.itemName = props.itemName;\n        this.matrix = props.matrix || new Matrix(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n        this.filters = props.filters || null;\n        this.color = props.color || null;\n        //this.position = props.position;\n        //this.scale = props.scale;\n        //this.rotation = props.rotation;\n        this.frame = props.frame;\n        this.index = this.frame.instances.length;\n    }\n\n\n    public get prev():Instance|undefined{\n        const item = this.frame.prev?.instances[this.index]\n        return item?.itemName==this.itemName ? item : undefined \n    }\n\n\n    public get next():Instance|undefined{\n        const item = this.frame.next?.instances[this.index]\n        return item?.itemName==this.itemName ? item : undefined\n    }\n\n\n    public get item():Drawable{\n        throw(\"Override item getter in base class\");\n    }\n\n\n    public draw(frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void):void{\n        this.library.scene.draw(this.item, frame, lerp, callback)\n    }\n\n\n}","import { Float } from \"../types/Float\";\n\nexport class Matrix{\n\n    _00:Float; _01:Float; _02:Float; _03:Float;\n    _10:Float; _11:Float; _12:Float; _13:Float;\n    _20:Float; _21:Float; _22:Float; _23:Float;\n    _30:Float; _31:Float; _32:Float; _33:Float;\n\n    data:Float32Array\n\n\n    constructor(\n        _00:Float, _01:Float, _02:Float, _03:Float,\n        _10:Float, _11:Float, _12:Float, _13:Float,\n        _20:Float, _21:Float, _22:Float, _23:Float,\n        _30:Float, _31:Float, _32:Float, _33:Float,\n    ){\n        this._00=_00; this._01=_01; this._02=_02; this._03=_03; \n        this._10=_10; this._11=_11; this._12=_12; this._13=_13; \n        this._20=_20; this._21=_21; this._22=_22; this._23=_23; \n        this._30=_30; this._31=_31; this._32=_32; this._33=_33; \n        \n        this.data = new Float32Array([\n            _00, _01, _02, _03,\n            _10, _11, _12, _13,\n            _20, _21, _22, _23,\n            _30, _31, _32, _33,\n        ])\n    }\n\n}","\nexport function modWrap(a:number, b:number){\n    return a - b * Math.floor(a/b);\n}\n","import { Instance, InstanceProps } from \"./Instance\";\n\n\nexport type SpriteInstanceProps = InstanceProps & {\n\n}\n\n\nexport class SpriteInstance extends Instance{\n\n    constructor(props:SpriteInstanceProps){\n        super(props)\n    }\n\n    \n    public get item(){\n        return this.library.spritesByName[this.itemName];\n    }\n\n\n}\n","import { Drawable } from \"./Drawable\";\nimport { Atlas } from \"./Atlas\";\nimport { DrawableProps } from \"./Drawable\"\nimport { Float } from \"./types/Float\";\n\n\nexport type SpriteProps = Omit<DrawableProps, 'totalFrames'|'library'|'id'> & {\n    x:Float,\n    y:Float,\n    width:Float,\n    height:Float,\n    rotated:boolean,\n    atlas:Atlas,\n}\n\n\nexport class Sprite extends Drawable{\n    x:Float;\n    y:Float;\n    width:Float;\n    height:Float;\n    rotated:boolean;\n    atlas:Atlas;\n\n    constructor(props:SpriteProps){\n        super({\n            ...props,\n            totalFrames:1,\n            library:props.atlas.library,\n            id:`${props.atlas.library.name}.sprites.${props.name}`\n        })\n        this.x = props.x;\n        this.y = props.y;\n        this.width = props.width;\n        this.height = props.height;\n        this.rotated = props.rotated;\n        this.atlas = props.atlas;\n    }\n\n\n    public getPixel(x:Float, y:Float, transform:DOMMatrix){\n        const point = new DOMPoint(x, y)\n        const imatrix = transform.inverse()\n        const local = point.matrixTransform(imatrix)\n\n        if(local.x<0 || local.x>=this.width) return null;\n        if(local.y<0 || local.y>=this.height) return null;\n\n        return this.atlas.getPixel(this.x + local.x, this.y + local.y)\n    }\n\n\n    public isSolidPixelAt(x:Float, y:Float, transform:DOMMatrix, alphaThreshold:number = 1){\n        const pixel = this.getPixel(x, y, transform)\n        return pixel && pixel[3] > alphaThreshold\n    }\n\n\n    public draw(frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void){\n        this.scene.drawImage(this.atlas.image, this.x, this.y, this.width, this.height, 0, 0, this.width, this.height)\n    }\n\n}\n","import { Library } from \"./Library\";\nimport { Scene } from \"./Scene\";\nimport { Sprite } from \"./Sprite\";\nimport { Float } from \"./types/Float\";\n\n\nexport type AtlasProps = {\n    library:Library,\n    image:HTMLImageElement,\n    app:string,\n    version:string,\n    imagePath:string,\n    format:string,\n    size:{w:Float, h:Float},\n    resolution:string,\n    pixelData: ReturnType<Scene['getPixelData']>,\n}\n\n\nexport class Atlas{\n    library:Library;\n    sprites:Array<Sprite>;\n    image:HTMLImageElement;\n\n    app:string;\n    version:string;\n    imagePath:string;\n    format:string;\n    size:{w:Float, h:Float};\n    resolution:string;\n    pixelData: ReturnType<Scene['getPixelData']>;\n\n    \n    constructor(props:AtlasProps){\n        this.sprites = [];\n        this.library = props.library;\n        this.image = props.image;\n        this.app = props.app;\n        this.version = props.version;\n        this.imagePath = props.imagePath;\n        this.format = props.format;\n        this.size = props.size;\n        this.resolution = props.resolution;\n        this.pixelData = props.pixelData;\n\n        // this.library.scene.getPixelData(this.image) // TODO: Determine if this should be a lazy operation\n    }\n\n\n\n    getPixel(x:Float, y:Float){\n        x = Math.floor(x)\n        y = Math.floor(y)\n        \n        let i = x + (y*this.pixelData.imageData.width)\n\n        const data = this.pixelData.imageData.data\n        return [\n            data[(i*4) + 0],\n            data[(i*4) + 1],\n            data[(i*4) + 2],\n            data[(i*4) + 3],\n        ]\n    }\n\n\n}\n","import { JsonAnimationData } from \"./AnimationJson\";\n\nconst keys:Record<string, string> = {\n    // Fix inconsistent names\n\n    // spritemap.json\n    SPRITE: \"sprite\",\n    SPRITES: \"sprites\",\n    ATLAS: \"atlas\",\n\n    // Animation.json\n    ANIMATION: \"animation\",\n    ATLAS_SPRITE_instance: \"atlasSpriteInstance\",\n    DecomposedMatrix: \"decomposedMatrix\",\n    Frames: \"frames\",\n    framerate: \"frameRate\",\n    Instance_Name: \"instanceName\",\n    Layer_name: \"layerName\",\n    Layer_type: \"layerType\",\n    Clipped_by: \"clippedBy\",\n    LAYERS: \"layers\",\n    Matrix3D: \"matrix3D\",\n    Position: \"position\",\n    Rotation: \"rotation\",\n    Scaling: \"scaling\",\n    SYMBOL_DICTIONARY: \"symbolDictionary\",\n    SYMBOL_Instance: \"symbolInstance\",\n    SYMBOL_name: \"symbolName\",\n    Symbols: \"symbols\",\n    TIMELINE: \"timeline\",\n\n\n    // Filter\n    GradientEntries: \"gradientEntries\",\n\n    // Color\n    RedMultiplier: 'redMultiplier',\n    AlphaOffset: 'alphaOffset',\n\n     // Animation.json optimised\n     AN: \"animation\",\n     AM: \"alphaMultiplier\",\n     ASI: \"atlasSpriteInstance\",\n     BM: \"bitmap\",\n     C: \"color\",\n     DU: \"duration\",\n     E: \"elements\",\n     FF: \"firstFrame\",\n     FR: \"frames\",\n     FRT: \"frameRate\",\n     I: \"index\",\n     IN: \"instanceName\",\n     L: \"layers\",\n     LN: \"layerName\",\n     LP: \"loop\",\n     M3D: \"matrix3D\",\n     MD: \"metadata\",\n     M: \"mode\",\n     N: \"name\",\n     POS: \"position\",\n     S: \"symbols\",\n     SD: \"symbolDictionary\",\n     SI: \"symbolInstance\",\n     SN: \"symbolName\",\n     ST: \"symbolType\",\n     TL: \"timeline\",\n     TRP: \"transformationPoint\",\n};\n\n\nfunction normaliseKey(key:string){\n    return keys[key] || key;\n}\n\n\n\n// AnimateCC exports wildy inconsistent JSON. Normalise the\n// fields to make it easier to work with\nexport function normaliseJson(data:any):any{\n    if(typeof data == \"string\" || typeof data == \"number\") return data\n    switch(typeof data){\n        case \"string\": return data;\n        case \"number\": return data;\n        case \"boolean\": return data;\n        case \"object\":\n            if(Array.isArray(data)){\n                return (data as Array<any>).map(normaliseJson);\n            }else{\n                var result:any = {};\n                Object.keys(data).forEach(key => result[normaliseKey(key)] = normaliseJson(data[key]));\n                return result;\n            }\n        case \"bigint\": throw(\"Not supported\");\n        case \"function\": throw(\"Not supported\");\n        case \"symbol\": throw(\"Not supported\");\n        case \"undefined\": throw(\"Not supported\");\n        default: throw(\"Unsupported\")\n    }\n}\n","export const createImage:(src:string)=>Promise<HTMLImageElement> = (src:string) =>\n    new Promise(resolve => {\n        const img = new Image();\n        img.src = src;\n        img.onload = () => resolve(img);\n        img.onerror = () => { throw(\"Image did not load: \" + img.src) }\n    });"],"names":["$bff6e8b75c713db0$export$38af1803e3442a7f","this","draw","drawImage","pixelData","mouseX","mouseY","createLibrary","name","path","$inlgY","Library","getPixelData","image","complete","canvas","document","createElement","width","height","ctx","getContext","imageData","getImageData","$ec7ebbd3c3493112$export$3fc34a660ecf5e3f","scene","clips","clipsByName","spritesByName","atlases","atlasesBySpriteName","symbol","createAtlas","props","atlas","$2xEof","Atlas","library","push","createSprite","sprite","$7oRJk","Sprite","sprites","createClip","clip","$iwtVH","Clip","animJsonPath","animFetchResult","fetch","dataRaw","json","data","$jvByp","normaliseJson","spriteNames","symbolData","symbolDictionary","symbols","symbolName","l","timeline","layers","length","layerData","layer","createLayer","layerName","type","layerType","clippedBy","frameData","frames","frame","createFrame","index","totalFrames","duration","labelName","elemInstanceData","elements","elemData","symbolInstance","m","matrix3D","instanceProps","filters","matrix","$eU0bP","Matrix","m00","m01","m02","m03","m10","m11","m12","m13","m20","m21","m22","m23","m30","m31","m32","m33","itemName","color","createClipInstance","transformationPoint","$fth7J","Vec2","behaviour","symbolType","loop","firstFrame","atlasSpriteInstance","spriteInstance","createSpriteInstance","indexOf","pendingAtlasIndex","spriteName","spriteJsonPath","altasFetch","imagePath","$dLlt9","createImage","app","meta","version","format","size","resolution","spriteSpriteData","spriteData","x","y","w","h","rotated","$e80e1193008ca0bb$export$9907240837c74db","$ckyqm","Drawable","super","id","layersById","layersByName","framesById","framesByLabel","$grEWN","Layer","__addFrame","lerp","callback","f","$ixNXR","modWrap","$3d71fa2bbc5264bb$export$f35845279390eafd","$f8c0e95ba29ab168$export$936d0764594b6eb3","framesByName","labels","$b16Gm","Frame","lastFrame","next","prev","keyframeAt","keyframe","$7caf8dbb28543dc2$export$b89a827e9254211a","instances","clipInstance","$37DlR","ClipInstance","$1WBAd","SpriteInstance","instance","$71b257484642d58f$export$4098ff56363e3bd4","$aIUQE","Instance","item","$b86f9c2a0fadb351$export$ac4bca90992eed1","Float32Array","$357bc7f5f80d4cde$export$38456927afaf190a","undefined","$b1883d23f40da57b$export$5b12bf1653c0dd85","_00","_01","_02","_03","_10","_11","_12","_13","_20","_21","_22","_23","_30","_31","_32","_33","$fb12499c5930ea0c$export$439a2f2d4388dcb6","a","b","Math","floor","$2271301cd6491edb$export$7fc9874af22ef896","$2e05ba0f314fe3e0$export$3075603db8e6204c","getPixel","transform","point","DOMPoint","imatrix","inverse","local","matrixTransform","isSolidPixelAt","alphaThreshold","pixel","$b2810d7beaf6dda0$export$e47fdbcb2ea069e5","i","$1ba5eed07923555c$var$keys","SPRITE","SPRITES","ATLAS","ANIMATION","ATLAS_SPRITE_instance","DecomposedMatrix","Frames","framerate","Instance_Name","Layer_name","Layer_type","Clipped_by","LAYERS","Matrix3D","Position","Rotation","Scaling","SYMBOL_DICTIONARY","SYMBOL_Instance","SYMBOL_name","Symbols","TIMELINE","GradientEntries","RedMultiplier","AlphaOffset","AN","AM","ASI","BM","C","DU","E","FF","FR","FRT","I","IN","L","LN","LP","M3D","MD","M","N","POS","S","SD","SI","SN","ST","TL","TRP","$1ba5eed07923555c$export$1dc9cf14c3c49af1","Array","isArray","map","result","Object","keys","forEach","key","$1ba5eed07923555c$var$normaliseKey","$d64e7ac1b386d3e1$export$ec664d7487540b","src","Promise","resolve","img","Image","onload","onerror"],"version":3,"file":"index.f6f6dd79.js.map"}