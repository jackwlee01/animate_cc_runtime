{
  "version": 3,
  "sources": ["../src/examples/example-utils.ts", "../src/core/Drawable.ts", "../src/core/Instance.ts", "../src/core/util/math.ts", "../src/core/ClipInstance.ts", "../src/core/SpriteInstance.ts", "../src/core/Frame.ts", "../src/core/Layer.ts", "../src/core/Clip.ts", "../src/core/geom/Vec2.ts", "../src/core/geom/Matrix2d.ts", "../src/core/Sprite.ts", "../src/core/Atlas.ts", "../src/core/json/utilJson.ts", "../src/core/geom/Matrix3d.ts", "../src/core/Library.ts", "../src/core/Scene.ts", "../src/Canvas2dScene.ts", "../src/examples/symbol-explorer.ts"],
  "sourcesContent": ["import { Clip } from \"../core/Clip\";\nimport { Library } from \"../core/Library\";\n\n\nexport function setupCanvas(canvas:HTMLCanvasElement) {\n    // Set the context quality and smoothing\n    const ctx = canvas.getContext('2d')!\n    ctx.imageSmoothingEnabled = true;\n    ctx.imageSmoothingQuality = 'high'\n\n    // Set the canvas according to window width\n    var bodyRec = document.body.getBoundingClientRect();\n    canvas.width = Math.min(1000, bodyRec.width - 8);\n    canvas.height = canvas.width;\n\n    // Get the device pixel ratio, falling back to 1.\n    let dpr = window.devicePixelRatio || 1;\n\n    // Get the size of the canvas in CSS pixels.\n    let rect = canvas.getBoundingClientRect();\n    \n    // Give the canvas pixel dimensions of their CSS\n    // size * the device pixel ratio.\n    //canvas.style.border = \"2px solid gray\";\n    canvas.style.width = \"\" + canvas.width + \"px\";\n    canvas.style.height = \"\" + canvas.height + \"px\";\n    canvas.width = rect.width * dpr;\n    canvas.height = rect.height * dpr;\n\n    return dpr;\n}\n\n\n\nexport function addExampleButtons(libraryKey:string, libs:Record<string, Library>, onLibrarySelected:(nextLibrary:Library)=>void, onSymbolPicked:(nextSymbol:Clip)=>void, onMinus:()=>void, onPlus:()=>void){\n    const library = libs[libraryKey]\n    const buttons = document.getElementById(\"buttons\")!\n\n    const selector = document.createElement('select')\n    selector.value = libraryKey\n    selector.onchange = (e) => {\n        const buttons = document.getElementById('buttons')!\n        while(buttons.childNodes.length > 0) buttons.childNodes[0].remove();\n        addExampleButtons(selector.value, libs, onLibrarySelected, onSymbolPicked, onMinus, onPlus)\n        onLibrarySelected(libs[selector.value])\n    }\n    buttons.appendChild(selector)\n    for(const libraryName of Object.keys(libs)){\n        const option = document.createElement('option')\n        option.value = libraryName\n        option.selected = libraryName == libraryKey\n        option.innerText = libraryName\n        selector.appendChild(option)\n    }\n\n    const minusButton = document.createElement('button')\n    minusButton.innerHTML = '-'\n    minusButton.onclick = onMinus\n    buttons.appendChild(minusButton);\n\n    const plusButton = document.createElement('button')\n    plusButton.innerHTML = '+'\n    plusButton.onclick = onPlus\n    buttons.appendChild(plusButton);\n\n    for(const clip of library.clips){\n        if(clip.name.indexOf(\"/\")!=-1 || clip.name.indexOf(\"Symbol \")==0 || clip.name.indexOf(\"Tween \")==0 || clip.name.indexOf(\"/Symbol \")!=-1 || clip.name.indexOf(\"/Tween \")!=-1) continue;\n        var button = document.createElement(\"button\")\n        button.innerHTML = clip.name\n        button.onclick = () => onSymbolPicked(clip)\n        buttons.appendChild(button)\n    }\n}", "import { Library } from \"./Library\";\n\ntype Int = number;\ntype Float = number;\n\n\nexport type DrawableProps = {\n    name:string,\n    id:string,\n    totalFrames:Int,\n    library:Library;\n}\n\n\nexport abstract class Drawable{\n    name:string;\n    id:string;\n    totalFrames:Int = 1;\n    library:Library;\n\n\n    constructor(props:DrawableProps){\n        this.name = props.name;\n        this.id = props.id;\n        this.totalFrames = props.totalFrames;\n        this.library = props.library;\n    }\n\n\n    public get scene(){\n        return this.library.scene;\n    }\n\n\n    public visit(frame:Float, callback:(item:Drawable, frame:Float)=>void):void{\n        // Override in base class\n    }\n\n\n    public draw(frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void){\n        // Override in base class\n    }\n\n}", "import { Drawable } from \"./Drawable\";\nimport { Frame } from \"./Frame\";\nimport { Matrix2d } from \"./geom/Matrix2d\";\nimport { Vec3 } from \"./geom/Vec3\";\nimport { DrawableProps } from './Drawable'\nimport { Matrix3d } from \"./geom/Matrix3d\";\nimport { Color, Filters } from \"./json/AnimationJson\";\n\n\nexport type InstanceProps = Omit<DrawableProps, 'id' | 'library'> & {\n    itemName:string,\n    matrix2d:Matrix2d,\n    matrix3d:Matrix3d,\n    frame:Frame,\n    filters:Filters|null,\n    color:Color|null,\n    //position:Vec3,\n    //scale:Vec3,\n    //rotation:Vec3,\n}\n\n\nexport class Instance extends Drawable{\n\n    matrix2d:Matrix2d;\n    matrix3d:Matrix3d;\n    frame:Frame;\n    index:number;\n    itemName:string;\n    filters:Filters|null;\n    color:Color|null;\n    //position:Vec3;\n    //scale:Vec3;\n    //rotation:Vec3;\n    //filters = new Array<Filter>();\n\n    \n    constructor(props:InstanceProps){\n        super({\n            ...props,\n            library: props.frame.library,\n            id: `${props.frame.id}.${props.frame.instances.length}`,\n        });\n\n        this.itemName = props.itemName;\n        this.matrix2d = props.matrix2d;\n        this.matrix3d = props.matrix3d;\n        this.filters = props.filters;\n        this.color = props.color;\n        //this.position = props.position;\n        //this.scale = props.scale;\n        //this.rotation = props.rotation;\n        this.frame = props.frame;\n        this.index = this.frame.instances.length;\n    }\n\n\n    public get prev():Instance|undefined{\n        const item = this.frame.prev?.instances[this.index]\n        return item?.itemName==this.itemName ? item : undefined \n    }\n\n\n    public get next():Instance|undefined{\n        const item = this.frame.next?.instances[this.index]\n        return item?.itemName==this.itemName ? item : undefined\n    }\n\n\n    public get item():Drawable{\n        throw(\"Override item getter in base class\");\n    }\n\n\n    public draw(frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void):void{\n        this.library.scene.draw(this.item, frame, lerp, callback)\n    }\n\n\n    public visit(frame:Float, callback:(item:Drawable, frame:Float)=>void):void{\n        callback(this, frame)\n    }\n\n}", "\nexport function modWrap(a:number, b:number){\n    return a - b * Math.floor(a/b);\n}\n", "import { Drawable } from \"./Drawable\";\nimport { Vec2 } from \"./geom/Vec2\";\nimport { Instance } from \"./Instance\";\nimport { InstanceProps } from \"./Instance\"\nimport { modWrap } from \"./util/math\";\n\ntype LoopKind = 'loop' // TODO: HANDLE OTHER LOOP KINDS | 'PlayOnce' | 'SingleFrame' | 'PlayOnceReverse' | 'LoopReverse'\n\n\ntype ClipInstanceBehavior = {\n    type: 'graphic'\n    loop:LoopKind;\n    firstFrame:Float;\n} | {\n    type: 'movieclip'\n}\n\n\nexport type ClipInstanceProps = InstanceProps & { \n    transformationPoint:Vec2,   \n    behaviour:ClipInstanceBehavior\n}\n\n\nexport class ClipInstance extends Instance{\n\n    transformationPoint:Vec2\n    behaviour:ClipInstanceBehavior\n    \n    \n    constructor(props:ClipInstanceProps){\n        super(props);\n        this.behaviour = props.behaviour;\n        this.transformationPoint = props.transformationPoint;\n    }\n\n\n    public get item(){\n        return this.library.clipsByName[this.itemName];\n    }\n\n\n    public draw(frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void):void{\n        if(this.behaviour.type == 'graphic'){\n            frame = this.behaviour.firstFrame + modWrap(frame, 1);\n        }\n        this.library.scene.draw(this.item, frame, lerp, callback)\n    }\n\n\n    public visit(frame:Float, callback:(item:Drawable, frame:Float)=>void):void{\n        if(this.behaviour.type == 'graphic'){\n            frame = this.behaviour.firstFrame + modWrap(frame, 1);\n        }\n        callback(this, frame)\n    }\n\n}\n", "import { Instance, InstanceProps } from \"./Instance\";\n\ntype Float = number;\n\nexport type SpriteInstanceProps = InstanceProps & {\n\n}\n\n\nexport class SpriteInstance extends Instance{\n\n    constructor(props:SpriteInstanceProps){\n        super(props)\n    }\n\n    \n    public get item(){\n        return this.library.spritesByName[this.itemName];\n    }\n\n\n}\n", "import { ClipInstance, ClipInstanceProps } from \"./ClipInstance\";\nimport { Drawable } from \"./Drawable\";\nimport { Layer } from \"./Layer\";\nimport { SpriteInstance, SpriteInstanceProps } from \"./SpriteInstance\";\nimport { DrawableProps } from \"./Drawable\";\nimport { Instance } from \"./Instance\";\n\n\ntype Int = number;\n\n\nexport type FrameProps = Omit<DrawableProps, 'id' | 'library'> & {\n    index:Int,\n    layer:Layer,\n    labelName:string|undefined,\n}\n\n\nexport class Frame extends Drawable{\n\n    index:number\n    labelName:string|null;\n    layer:Layer;\n    instances:Array<ClipInstance|SpriteInstance> = [];\n    prev:Frame|undefined;\n    next:Frame|undefined;\n\n\n    constructor(props:FrameProps){\n        super({\n            ...props,\n            id: `${props.layer.id}.${props.index}`,\n            library: props.layer.library\n        });\n        \n        this.layer = props.layer;\n        this.index = props.index;\n        this.labelName = props.labelName || null;\n    }\n\n\n    public createClipInstance(props:Omit<ClipInstanceProps, 'frame'>){\n        const clipInstance = new ClipInstance({...props, frame:this})\n        this.instances.push(clipInstance)\n        return clipInstance;\n    }\n\n\n    public createSpriteInstance(props:Omit<SpriteInstanceProps, 'frame'>){\n        const spriteInstance = new SpriteInstance({...props, frame:this})\n        this.instances.push(spriteInstance)\n        return spriteInstance\n    }\n\n\n    public draw(frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float)=>void):void{\n        for(const instance of this.instances){\n            this.library.scene.draw(instance, frame, lerp, callback)\n        }\n    }\n\n\n    public visit(frame:Float, callback:(item:Drawable, frame:Float)=>void):void{\n        callback(this, frame)\n        for(const instance of this.instances){\n            instance.visit(frame, callback)\n        }\n    }\n\n}\n", "import { Clip } from \"./Clip\";\nimport { Drawable } from \"./Drawable\";\nimport { Frame, FrameProps } from \"./Frame\";\nimport { DrawableProps } from \"./Drawable\"\nimport { modWrap } from \"./util/math\";\n\n\ntype Int = number;\ntype Float = number;\n\n\nexport type LayerProps = Omit<DrawableProps, 'totalFrames'|'id'|'library'> & {\n    clip:Clip\n    type: 'Normal'|'Clipper',\n    clippedBy:null|string\n}\n\n\nexport class Layer extends Drawable{\n\n    public index:Int;\n    public type: LayerProps['type'];\n    public clippedBy:string|null;\n    public frames:Array<Frame>;\n    public framesByName:Record<string, Frame>;\n    public labels:Array<Frame>;\n    public clip:Clip;\n\n\n    constructor(props:LayerProps){\n        super({\n            ...props,\n            totalFrames:0,\n            id:`${props.clip.id}.${props.name}`,\n            library: props.clip.library,\n        });\n        \n        this.clip = props.clip;\n        this.type = props.type;\n        this.clippedBy = props.clippedBy;\n        this.index = this.clip.layers.length;\n        this.frames = [];\n        this.framesByName = {};\n        this.labels = [];\n    }\n\n\n    public createFrame(props:Omit<FrameProps, 'layer'>){\n        const frame = new Frame({...props, layer:this});\n\n        // TODO: Allow for more flexibility when adding frames\n        if(this.frames.length>0 && this.lastFrame.index+this.lastFrame.totalFrames != frame.index) throw(\"Must add next frame at previous frame.index+frame.duration\")\n\n        this.framesByName[frame.name] = frame;\n        if(frame.index+frame.totalFrames > this.totalFrames) this.totalFrames = frame.index+frame.totalFrames\n        if(frame.labelName){\n            this.labels.push(frame);\n        }\n        this.clip.addFrame(frame);\n        /*\n        if(this.firstFrame){\n            this.firstFrame.prev = frame\n            frame.next = this.firstFrame\n        }\n        */\n        if(this.lastFrame){\n            this.lastFrame.next = frame\n            frame.prev = this.lastFrame\n        }\n        this.frames.push(frame)\n        return frame;\n    }\n\n\n    public get lastFrame(){\n        return this.frames[this.frames.length-1];\n    }\n\n\n    public get firstFrame(){\n        return this.frames[0];\n    }\n\n\n    public keyframeAt(frame:Float){\n        // TODO: Binary search would be a good optimisation here\n        frame = modWrap(frame, this.totalFrames);\n        for(const keyframe of this.frames){\n            if(keyframe.index<=frame && keyframe.index+keyframe.totalFrames > frame)\n            return keyframe;\n        }\n        return null;\n    }\n\n\n    public draw(frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void):void{\n        var keyframe = this.keyframeAt(frame)\n        if(keyframe!=null){\n            this.library.scene.draw(keyframe, frame, lerp, callback);\n        }\n    }\n\n\n    public visit(frame:Float, callback:(item:Drawable, frame:Float)=>void):void{\n        callback(this, frame);\n        var keyframe = this.keyframeAt(frame)\n        if(keyframe!=null){\n            keyframe.visit(frame, callback)\n        }\n    }\n\n}\n", "import { Drawable } from \"./Drawable\";\nimport { Frame } from \"./Frame\";\nimport { Layer, LayerProps } from \"./Layer\";\nimport { DrawableProps } from './Drawable'\nimport { modWrap } from \"./util/math\";\n\ntype Float = number;\nexport type ClipProps = Omit<DrawableProps, 'totalFrames'|'id'>\n\n\nexport class Clip extends Drawable{\n\n    layers:Array<Layer>;\n    layersById:Record<string, Layer>;\n    layersByName:Record<string, Layer>;\n    framesById:Record<string, Frame>;\n\n\n    constructor(props:ClipProps){\n        super({\n            ...props,\n            totalFrames:0,\n            id:`${props.library.name}.clips.${props.name}`,\n        })\n        \n        this.layers = [];\n        this.layersById = {};\n        this.layersByName = {};\n        this.framesById = {};\n    }\n\n\n    public createLayer(props:Omit<LayerProps, 'clip'>){\n        const layer = new Layer({...props, clip:this});\n        this.layers.push(layer);\n        this.layersById[layer.id] = layer;\n        this.layersByName[layer.name] = layer;\n        if(layer.totalFrames > this.totalFrames) this.totalFrames = layer.totalFrames;\n\n        return layer;\n    }\n\n\n    public addFrame(frame:Frame){\n        this.framesById[frame.id] = frame;\n        if(frame.layer.totalFrames > this.totalFrames) this.totalFrames = frame.layer.totalFrames;\n    }\n\n\n    public draw(frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void){\n        for(const layer of this.layers){\n            if(layer.totalFrames==0) continue;\n            var f = modWrap(frame, layer.totalFrames);\n            if(layer.totalFrames>=f){\n                this.library.scene.draw(layer, frame, lerp, callback);\n            }\n        }\n    }\n\n\n    public visit(frame:Float, callback:(item:Drawable, frame:Float)=>void):void{\n        callback(this, frame)\n        for(const layer of this.layers){\n            if(layer.totalFrames==0) continue;\n            var f = modWrap(frame, layer.totalFrames);\n            if(layer.totalFrames>=f) layer.visit(frame, callback)\n        }\n    }\n\n\n   \n}", "type Float = number;\n\n\nexport class Vec2 {\n\n    x:Float\n    y:Float\n    data:Float32Array\n\n    \n    constructor(props:{x:Float, y:Float}){\n        this.x = props.x\n        this.y = props.y\n        this.data = new Float32Array([this.x, this.y])\n    }\n    \n}", "\nexport class Matrix2d{\n\n    a:number\n    b:number\n    c:number\n    d:number\n    e:number\n    f:number\n    data:Float32Array\n\n\n    constructor(a:number, b:number, c:number, d:number, e:number, f:number){\n        this.a = a\n        this.b = b\n        this.c = c\n        this.d = d\n        this.e = e\n        this.f = f\n        \n        this.data = new Float32Array([this.a, this.b, this.c, this.d, this.e, this.f])\n    }\n\n}", "import { Drawable } from \"./Drawable\";\nimport { Atlas } from \"./Atlas\";\nimport { DrawableProps } from \"./Drawable\"\n\ntype Int = number;\ntype Float = number;\n\n\nexport type SpriteProps = Omit<DrawableProps, 'totalFrames'|'library'|'id'> & {\n    x:Float,\n    y:Float,\n    width:Float,\n    height:Float,\n    rotated:boolean,\n    atlas:Atlas,\n}\n\n\nexport class Sprite extends Drawable{\n    x:Float;\n    y:Float;\n    width:Float;\n    height:Float;\n    rotated:boolean;\n    atlas:Atlas;\n\n    constructor(props:SpriteProps){\n        super({\n            ...props,\n            totalFrames:1,\n            library:props.atlas.library,\n            id:`${props.atlas.library.name}.sprites.${props.name}`\n        })\n        this.x = props.x;\n        this.y = props.y;\n        this.width = props.width;\n        this.height = props.height;\n        this.rotated = props.rotated;\n        this.atlas = props.atlas;\n    }\n\n\n    public draw(frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void){\n        // Override in base class\n    }\n\n\n    public visit(frame:Float, callback:(item:Drawable, frame:Float)=>void):void{\n        callback(this, frame)\n    }\n   \n}\n", "import { Library } from \"./Library\";\nimport { Sprite } from \"./Sprite\";\n\n\nexport type AtlasProps = {\n    library:Library,\n    image:HTMLImageElement,\n    app:string,\n    version:string,\n    imagePath:string,\n    format:string,\n    size:{w:Float, h:Float},\n    resolution:string\n}\n\n\nexport class Atlas{\n    library:Library;\n    sprites:Array<Sprite>;\n    image:HTMLImageElement;\n\n    app:string;\n    version:string;\n    imagePath:string;\n    format:string;\n    size:{w:Float, h:Float};\n    resolution:string;\n\n    \n    constructor(props:AtlasProps){\n        this.sprites = [];\n        this.library = props.library;\n        this.image = props.image;\n        this.app = props.app;\n        this.version = props.version;\n        this.imagePath = props.imagePath;\n        this.format = props.format;\n        this.size = props.size;\n        this.resolution = props.resolution;\n    }\n\n    \n\n}\n", "import { AnimationJson } from \"./AnimationJson\";\n\nconst keys:Record<string, string> = {\n    // Fix inconsistent names\n\n    // spritemap.json\n    SPRITE: \"sprite\",\n    SPRITES: \"sprites\",\n    ATLAS: \"atlas\",\n\n    // Animation.json\n    ANIMATION: \"animation\",\n    ATLAS_SPRITE_instance: \"atlasSpriteInstance\",\n    DecomposedMatrix: \"decomposedMatrix\",\n    Frames: \"frames\",\n    framerate: \"frameRate\",\n    Instance_Name: \"instanceName\",\n    Layer_name: \"layerName\",\n    Layer_type: \"layerType\",\n    Clipped_by: \"clippedBy\",\n    LAYERS: \"layers\",\n    Matrix3D: \"matrix3D\",\n    Position: \"position\",\n    Rotation: \"rotation\",\n    Scaling: \"scaling\",\n    SYMBOL_DICTIONARY: \"symbolDictionary\",\n    SYMBOL_Instance: \"symbolInstance\",\n    SYMBOL_name: \"symbolName\",\n    Symbols: \"symbols\",\n    TIMELINE: \"timeline\",\n\n\n    // Filter\n    GradientEntries: \"gradientEntries\",\n\n    // Color\n    RedMultiplier: 'redMultiplier',\n    AlphaOffset: 'alphaOffset',\n\n     // Animation.json optimised\n     AN: \"animation\",\n     AM: \"alphaMultiplier\",\n     ASI: \"atlasSpriteInstance\",\n     BM: \"bitmap\",\n     C: \"color\",\n     DU: \"duration\",\n     E: \"elements\",\n     FF: \"firstFrame\",\n     FR: \"frames\",\n     FRT: \"frameRate\",\n     I: \"index\",\n     IN: \"instanceName\",\n     L: \"layers\",\n     LN: \"layerName\",\n     LP: \"loop\",\n     M3D: \"matrix3D\",\n     MD: \"metadata\",\n     M: \"mode\",\n     N: \"name\",\n     POS: \"position\",\n     S: \"symbols\",\n     SD: \"symbolDictionary\",\n     SI: \"symbolInstance\",\n     SN: \"symbolName\",\n     ST: \"symbolType\",\n     TL: \"timeline\",\n     TRP: \"transformationPoint\",\n};\n\n\nfunction normaliseKey(key:string){\n    return keys[key] || key;\n}\n\n\n\n// AnimateCC exports wildy inconsistent JSON. Normalise the\n// fields to make it easier to work with\nexport function normaliseJson(data:any):any{\n    if(typeof data == \"string\" || typeof data == \"number\") return data\n    switch(typeof data){\n        case \"string\": return data;\n        case \"number\": return data;\n        case \"boolean\": return data;\n        case \"object\":\n            if(Array.isArray(data)){\n                return (data as Array<any>).map(normaliseJson);\n            }else{\n                var result:any = {};\n                Object.keys(data).forEach(key => result[normaliseKey(key)] = normaliseJson(data[key]));\n                return result;\n            }\n        case \"bigint\": throw(\"Not supported\");\n        case \"function\": throw(\"Not supported\");\n        case \"symbol\": throw(\"Not supported\");\n        case \"undefined\": throw(\"Not supported\");\n        default: throw(\"Unsupported\")\n    }\n}\n", "\nexport class Matrix3d{\n\n    _00:number; _01:number; _02:number; _03:number;\n    _10:number; _11:number; _12:number; _13:number;\n    _20:number; _21:number; _22:number; _23:number;\n    _30:number; _31:number; _32:number; _33:number;\n\n    data:Float32Array\n\n\n    constructor(\n        _00:number, _01:number, _02:number, _03:number,\n        _10:number, _11:number, _12:number, _13:number,\n        _20:number, _21:number, _22:number, _23:number,\n        _30:number, _31:number, _32:number, _33:number,\n    ){\n        this._00=_00; this._01=_01; this._02=_02; this._03=_03; \n        this._10=_10; this._11=_11; this._12=_12; this._13=_13; \n        this._20=_20; this._21=_21; this._22=_22; this._23=_23; \n        this._30=_30; this._31=_31; this._32=_32; this._33=_33; \n        \n        this.data = new Float32Array([\n            _00, _01, _02, _03,\n            _10, _11, _12, _13,\n            _20, _21, _22, _23,\n            _30, _31, _32, _33,\n        ])\n    }\n\n}", "import { AnimationJson } from \"./json/AnimationJson\";\nimport { Clip, ClipProps } from \"./Clip\";\nimport { ClipInstanceProps } from \"./ClipInstance\";\nimport { SpriteInstanceProps } from \"./SpriteInstance\";\nimport { Vec3 } from \"./geom/Vec3\";\nimport { Vec2 } from \"./geom/Vec2\";\nimport { Matrix2d } from \"./geom/Matrix2d\";\nimport { InstanceProps } from \"./Instance\";\nimport { DrawableProps } from \"./Drawable\";\nimport { Sprite, SpriteProps } from \"./Sprite\";\nimport { Atlas, AtlasProps } from \"./Atlas\";\nimport { normaliseJson } from \"./json/utilJson\";\nimport { Scene } from \"./Scene\";\nimport { Matrix3d } from \"./geom/Matrix3d\";\n\n\nexport class Library{\n\n    name:string;\n    path:string;\n    clips:Array<Clip> = [];\n    clipsByName:Record<string, Clip> = {};\n    spritesByName:Record<string, Sprite> = {};\n    atlases:Array<Atlas> = [];\n    atlasesBySpriteName:Record<string, Atlas> = {}\n    scene:Scene;\n    \n    \n    constructor(name:string, path:string, scene:Scene){\n        this.name = name;\n        this.path = path;\n        this.atlases = [];\n        this.scene = scene;\n    }\n\n\n    symbol(name:string){\n        if(this.clipsByName[name]) return this.clipsByName[name]\n        if(this.spritesByName[name]) return this.spritesByName[name]\n        throw(\"Cannot find symbol: \" + name + \" for library: \" + this.path);\n    }\n\n\n    createAtlas(props:Omit<AtlasProps, 'library'>){\n        const atlas = new Atlas({...props, library:this});\n        this.atlases.push(atlas);\n        return atlas;\n    }\n\n\n    createSprite(atlas:Atlas, props:Omit<SpriteProps, 'atlas'>){\n        const sprite = new Sprite({...props, atlas:atlas})\n        atlas.sprites.push(sprite);\n        this.spritesByName[sprite.name] = sprite;\n        this.atlasesBySpriteName[sprite.name] = atlas;\n        return sprite;\n    }\n\n\n    createClip(props:Omit<ClipProps, 'library'>){\n        const clip = new Clip({...props, library:this});\n        this.clips.push(clip)\n        this.clipsByName[clip.name] = clip\n        return clip;\n    }\n\n\n    public async loadData(){\n        const animJsonPath = this.path + \"/Animation.json\";\n        const animFetchResult = await fetch(animJsonPath);\n        const dataRaw:AnimationJson = await animFetchResult.json();\n        const data = normaliseJson(dataRaw) as AnimationJson;\n        const spriteNames:Array<string> = [];\n\n        // Clip\n        for(const symbolData of data.symbolDictionary.symbols){\n            const clip = this.createClip({\n                name: symbolData.symbolName,\n            })\n\n            // Layer\n            for(let l=symbolData.timeline.layers.length-1; l>=0; l--){\n                const layerData = symbolData.timeline.layers[l]\n                const layer = clip.createLayer({\n                    name: layerData.layerName,\n                    type: layerData.layerType || 'Normal',\n                    clippedBy: layerData.clippedBy || null,\n                })\n\n                // Frame\n                for(const frameData of layerData.frames){\n                    const frame = layer.createFrame({\n                        name: \"\"+frameData.index,\n                        totalFrames: frameData.duration,\n                        labelName: frameData.name,\n                        index: frameData.index,\n                    })\n\n                    // Element\n                    for(const elemInstanceData of  frameData.elements){\n                        if(\"symbolInstance\" in elemInstanceData){\n                            type _DrawableProps = Pick<DrawableProps, keyof DrawableProps & keyof ClipInstanceProps>;\n                            type _InstanceProps = Omit<InstanceProps, keyof DrawableProps>\n                            \n                            const elemData = elemInstanceData.symbolInstance;\n                            const m = elemData.matrix3D;\n\n                            const drawableProps:_DrawableProps = {\n                                name: frame.name,\n                                totalFrames: frame.totalFrames,\n                            }\n\n                            const instanceProps:_InstanceProps  = {\n                                frame,\n                                filters: elemData.filters || null,\n                                matrix2d: 'm00' in m ? new Matrix2d(m.m00, m.m01, m.m10, m.m11, m.m30, m.m31) : new Matrix2d(m[0], m[1], m[4], m[5], m[12], m[13]),\n                                matrix3d: 'm00' in m ? new Matrix3d(m.m00, m.m01, m.m02, m.m03,\n                                                                    m.m10, m.m11, m.m12, m.m13,\n                                                                    m.m20, m.m21, m.m22, m.m23,\n                                                                    m.m30, m.m31, m.m32, m.m33)\n                                                     : new Matrix3d(m[ 0], m[ 1], m[ 2], m[ 3],\n                                                                    m[ 4], m[ 5], m[ 6], m[ 7],\n                                                                    m[ 8], m[ 9], m[10], m[11],\n                                                                    m[12], m[13], m[14], m[15]),\n                                itemName: elemData.symbolName,\n                                color: elemData.color || null,\n                                //position: new Vec3(elemData.decomposedMatrix.position),\n                                //scale: new Vec3(elemData.decomposedMatrix.scaling),\n                                //rotation: new Vec3(elemData.decomposedMatrix.rotation),\n                            }\n\n                            const clipInstance = frame.createClipInstance({\n                                ...drawableProps,\n                                ...instanceProps,\n                                transformationPoint: new Vec2(elemData.transformationPoint),\n                                behaviour: elemData.symbolType == \"graphic\"\n                                         ? { type: 'graphic', loop: elemData.loop, firstFrame: elemData.firstFrame}\n                                         : { type: 'movieclip' }\n                            })\n                        }else{\n                            type _DrawableProps = Pick<DrawableProps, keyof DrawableProps & keyof SpriteInstanceProps>;\n                            type _InstanceProps = Omit<InstanceProps, keyof DrawableProps>\n                            \n                            const elemData = elemInstanceData.atlasSpriteInstance;\n                            const m = elemData.matrix3D;\n\n                            const drawableProps:_DrawableProps = {\n                                name: frame.name,\n                                totalFrames: frame.totalFrames,\n                            }\n\n                            const instanceProps:_InstanceProps  = {\n                                frame,\n                                filters: elemData.filters || null,\n                                color: null,\n                                matrix2d: 'm00' in m ? new Matrix2d(m.m00, m.m01, m.m10, m.m11, m.m30, m.m31) : new Matrix2d(m[0], m[1], m[4], m[5], m[12], m[13]),\n                                matrix3d: 'm00' in m ? new Matrix3d(m.m00, m.m01, m.m02, m.m03,\n                                                                    m.m10, m.m11, m.m12, m.m13,\n                                                                    m.m20, m.m21, m.m22, m.m23,\n                                                                    m.m30, m.m31, m.m32, m.m33)\n                                                     : new Matrix3d(m[ 0], m[ 1], m[ 2], m[ 3],\n                                                                    m[ 4], m[ 5], m[ 6], m[ 7],\n                                                                    m[ 8], m[ 9], m[10], m[11],\n                                                                    m[12], m[13], m[14], m[15]),\n                                itemName: elemData.name,\n                                //position: new Vec3(elemData.decomposedMatrix.position),\n                                //scale: new Vec3(elemData.decomposedMatrix.scaling),\n                                //rotation: new Vec3(elemData.decomposedMatrix.rotation),\n                            }\n\n                            const spriteInstance = frame.createSpriteInstance({\n                                ...drawableProps,\n                                ...instanceProps,\n                            })\n\n                            if(spriteNames.indexOf(spriteInstance.itemName)==-1) spriteNames.push(spriteInstance.itemName)\n                        }\n                    }\n                }\n            }\n        };\n\n        // Sprites\n        let pendingAtlasIndex = 1;\n        for(const spriteName of spriteNames){\n            if(this.atlasesBySpriteName[spriteName]==null){\n                const spriteJsonPath = this.path + `/spritemap${pendingAtlasIndex}.json`;\n                const altasFetch = await fetch(spriteJsonPath);\n                const dataRaw:SpriteMapJson = await altasFetch.json();\n                const data = normaliseJson(dataRaw) as SpriteMapJson;\n\n                const image = new Image(data.meta.size.w, data.meta.size.h);\n                image.src = this.path + `/spritemap${pendingAtlasIndex}.png`;\n\n                \n                const atlas = this.createAtlas({\n                    image,\n                    app: data.meta.app,\n                    version: data.meta.version,\n                    imagePath: data.meta.image,\n                    format: data.meta.format,\n                    size: data.meta.size,\n                    resolution: data.meta.resolution \n                })\n                for(const spriteSpriteData of data.atlas.sprites){\n                    const spriteData = spriteSpriteData.sprite;\n                    const sprite = this.createSprite(atlas, {\n                        name: spriteData.name,\n                        x: spriteData.x,\n                        y: spriteData.y,\n                        width: spriteData.w,\n                        height: spriteData.h,\n                        rotated: spriteData.rotated,\n                    })\n                    this.atlasesBySpriteName[sprite.name] = atlas;\n                }\n\n\n                pendingAtlasIndex++;\n            }\n        }\n\n    }\n\n\n}\n", "import { Drawable } from \"./Drawable\";\nimport { Library } from \"./Library\";\n\n\nexport abstract class Scene{\n\n    draw: (item:Drawable, frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void) => void\n\n\n    constructor(){\n        this.draw = null! // OVERRIDE THIS IN THE BASE CLASS!\n    }\n\n\n    get mouseX():number{\n        throw(\"Override mouseX in base class\")\n    }\n\n\n    get mouseY():number{\n        throw(\"Override mouseY in base class\")\n    }\n\n  \n    createLibrary(name:string, path:string){\n        const library = new Library(name, path, this);\n        return library;\n    }\n\n\n}", "import { Scene } from \"./core/Scene\"\nimport { ClipInstance } from \"./core/ClipInstance\";\nimport { Drawable } from \"./core/Drawable\"\nimport { Frame } from \"./core/Frame\";\nimport { Instance } from \"./core/Instance\"\nimport { FilterDropShadow, FilterType } from \"./core/json/AnimationJson\";\nimport { Layer } from \"./core/Layer\";\nimport { Sprite } from \"./core/Sprite\"\nimport { SpriteInstance } from \"./core/SpriteInstance\";\nimport { modWrap } from \"./core/util/math\";\n\n\n// This is all of the library's rendering code required to draw into a canvas 2d context.\n// This could easily be ported to any immediate mode rendering context, ie WebGL.\n// This could also be ported to scene graph based libraries like PixiJS, or event the DOM,\n// with a few modification to faciliate mapping to a scene graph.\nexport class Canvas2dScene extends Scene{\n    \n    canvas:HTMLCanvasElement\n    stack:CanvasRenderingContext2D[]\n    pool:CanvasRenderingContext2D[];\n\n    private _mouseX:number;\n    private _mouseY:number;\n\n\n    constructor(ctx:CanvasRenderingContext2D){\n        super();\n        this.canvas = ctx.canvas\n        this.stack = [ctx]\n        this.pool = [];\n\n        this._mouseX = -1;\n        this._mouseY = -1;\n        ctx.canvas.addEventListener('mousemove', this.onMouseMove.bind(this))\n    }\n\n\n    onMouseMove(e:MouseEvent){\n        const rect = this.canvas.getBoundingClientRect()\n        const scaleX = this.canvas.width / rect.width\n        const scaleY = this.canvas.height / rect.height\n        this._mouseX = (e.clientX - rect.left) * scaleX\n        this._mouseY = (e.clientY - rect.top) * scaleY\n        console.log(this._mouseX, this._mouseY)\n    }\n\n\n    get mouseX(){\n        return 0\n    }\n\n\n    get mouseY(){\n        return 0\n    }\n\n\n    get ctx(){\n        return this.stack[this.stack.length-1]\n    }\n\n\n    pushRenderTarget(){\n        const ctx = this.pool.length==0 ? document.createElement('canvas').getContext('2d')! : this.pool.pop()!\n        ctx.canvas.width = this.ctx.canvas.width\n        ctx.canvas.height = this.ctx.canvas.height\n        ctx.setTransform(this.ctx.getTransform())\n        this.stack.push(ctx)\n    }\n\n\n    popRenderTarget(){\n        if(this.stack.length<=1) throw(\"Cannot pop stack\")\n        const ctx = this.stack.pop()!;\n        this.ctx.save();\n        this.ctx.resetTransform()\n        this.ctx.drawImage(ctx!.canvas, 0, 0);\n        this.ctx.restore();\n        this.pool.push(ctx)\n    }\n\n\n    draw = (item:Drawable, frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void) => {\n        if(item instanceof Layer){\n           if(item.type=='Clipper'){\n           }else if(item.clippedBy){\n                const clipLayer = item.clip.layersByName[item.clippedBy]\n                this.pushRenderTarget()\n                clipLayer.draw(frame, lerp, callback)\n                this.ctx.globalCompositeOperation = 'source-in'\n                if(callback) callback(item, frame, lerp)\n                else item.draw(frame, lerp, callback)\n                this.popRenderTarget()\n            }else{\n                if(callback) callback(item, frame, lerp)\n                else item.draw(frame, lerp, callback)\n            }\n        }else if(item instanceof Instance){\n            this.ctx.save()\n            this.transformInstance(item, frame, lerp)\n            const didPushContext = this.handleFilters(item, frame, lerp)\n            this.handleColor(item, frame, lerp)\n            if(callback) callback(item, frame, lerp)\n            else item.draw(frame, lerp, callback)\n            if(didPushContext) this.popRenderTarget()\n            this.ctx.restore()\n        }else if(item instanceof Sprite){\n            if(callback) callback(item, frame, lerp)\n            this.ctx.drawImage(item.atlas.image, item.x, item.y, item.width, item.height, 0, 0, item.width, item.height)\n        }else{\n            if(callback) callback(item, frame, lerp)\n            else item.draw(frame, lerp, callback)\n        }\n    }\n\n    \n    private handleColor(item:Instance, frame:Float, lerp?:boolean){\n        // TODO: Handle lerp on color\n        if(item.color?.mode == 'CA' || item.color?.mode == 'Alpha' || item.color?.mode == 'Advanced' || item.color?.mode == 'AD') this.ctx.globalAlpha *= item.color.alphaMultiplier;\n    }\n\n\n    private handleFilters(item:Instance, frame:Float, lerp?:boolean){\n        // TODO: Handle lerp on filters\n        if(item.filters){\n            for(let k of Object.keys(item.filters)){\n                const key = k as FilterType;\n                if(key=='DropShadowFilter'){\n                    const filter = item.filters[key] as FilterDropShadow;\n                    this.pushDropShadow(\n                        filter.color + (Math.round(filter.strength*255)).toString(16),\n                        filter.blurX,\n                        Math.cos(filter.angle*Math.PI/180) * filter.distance,\n                        Math.sin(filter.angle*Math.PI/180) * filter.distance,\n                    )\n                    return true;\n                }\n            }\n        }\n    }\n\n\n    pushDropShadow(color:string, blur:number, offsetX:Float=0, offsetY:Float=0){\n        this.ctx.shadowColor = color;\n        this.ctx.shadowBlur = blur;\n        this.ctx.shadowOffsetX = offsetX;\n        this.ctx.shadowOffsetY = offsetY;\n        this.pushRenderTarget();\n    }\n\n\n    popDropShadow(){\n        this.popRenderTarget();\n    }\n\n\n    private transformInstance(item:Instance, frame:Float, lerp?:boolean){\n        if(lerp && item.next){\n            const t = (modWrap(frame, item.totalFrames)-item.index) / item.frame.totalFrames;\n            const m1 = item.matrix2d\n            const m2 = item.next.matrix2d \n            this.ctx.transform(\n                m1.a + (m2.a-m1.a)*t,\n                m1.b + (m2.b-m1.b)*t,\n                m1.c + (m2.c-m1.c)*t,\n                m1.d + (m2.d-m1.d)*t,\n                m1.e + (m2.e-m1.e)*t,\n                m1.f + (m2.f-m1.f)*t,\n            )\n        }else{\n            this.ctx.transform(item.matrix2d.a, item.matrix2d.b, item.matrix2d.c, item.matrix2d.d, item.matrix2d.e, item.matrix2d.f)\n        }\n    }\n    \n}", "import { addExampleButtons, setupCanvas } from \"./example-utils\";\nimport { Canvas2dScene } from \"../Canvas2dScene\";\nimport { Clip } from \"../core/Clip\";\nimport { Library } from \"../core/Library\";\n\n\nconst canvas = document.getElementById(\"canvas\") as HTMLCanvasElement\nconst ctx2d = canvas.getContext('2d')!\nvar dpr = setupCanvas(canvas) // Device pixel ratio\n\n// Set up animation context and libraries\nconst scene = new Canvas2dScene(ctx2d)\nconst libraries = {\n    test: scene.createLibrary('test', './test'),\n    monsters: scene.createLibrary('monsters', './monsters'),\n}\n\n\nasync function init(){\n    // Load the libraries\n    await libraries.test.loadData();\n    await libraries.monsters.loadData();\n    update();\n}\n\n\n// Example state\nlet frame = 0;\nlet library = libraries[Object.keys(libraries)[0] as keyof typeof libraries]\nlet symbol =library.clips[0]\nvar colsAndRows = 1;\n\n// Set up example ui\nconst onSymbolPicked = (nextSymbol:Clip) => symbol=nextSymbol\nconst onMinus =  () => { if(colsAndRows > 1) colsAndRows-- }\nconst onPlus =  () => colsAndRows++\nconst onLibrarySeleced = (nextLibrary:Library) => {\n    library = nextLibrary\n    symbol = library.clips[0]\n}\n\naddExampleButtons(Object.keys(libraries)[0], libraries, onLibrarySeleced, onSymbolPicked, onMinus, onPlus)\n\n\nfunction update(){\n    scene.ctx.fillStyle = '#cccccc'\n    scene.ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    scene.ctx.save();\n    \n        scene.ctx.translate(canvas.width/2, canvas.height/2)\n        scene.ctx.scale(dpr, dpr)\n\n        const num = colsAndRows+1;\n        var xo = canvas.width/num/2;\n        var yo = canvas.height/num/2;\n    \n        for(var x = 1; x < num; x++){\n            for(var y = 1; y < num; y++){\n                scene.ctx.save();\n                    scene.ctx.translate(-(num*xo/2)+x*xo, -(num*yo/2)+y*xo)\n                    symbol.draw(frame)\n                scene.ctx.restore();\n            }\n        }\n    \n    scene.ctx.restore()\n    \n    frame++;\n    requestAnimationFrame(update)\n}\n\n\ninit();\n\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIO,uBAAqB,SAA0B;AAElD,UAAM,MAAM,QAAO,WAAW;AAC9B,QAAI,wBAAwB;AAC5B,QAAI,wBAAwB;AAG5B,QAAI,UAAU,SAAS,KAAK;AAC5B,YAAO,QAAQ,KAAK,IAAI,KAAM,QAAQ,QAAQ;AAC9C,YAAO,SAAS,QAAO;AAGvB,QAAI,OAAM,OAAO,oBAAoB;AAGrC,QAAI,OAAO,QAAO;AAKlB,YAAO,MAAM,QAAQ,KAAK,QAAO,QAAQ;AACzC,YAAO,MAAM,SAAS,KAAK,QAAO,SAAS;AAC3C,YAAO,QAAQ,KAAK,QAAQ;AAC5B,YAAO,SAAS,KAAK,SAAS;AAE9B,WAAO;AAAA;AAKJ,6BAA2B,YAAmB,MAA8B,mBAA+C,iBAAwC,UAAkB,SAAgB;AACxM,UAAM,WAAU,KAAK;AACrB,UAAM,UAAU,SAAS,eAAe;AAExC,UAAM,WAAW,SAAS,cAAc;AACxC,aAAS,QAAQ;AACjB,aAAS,WAAW,CAAC,MAAM;AACvB,YAAM,WAAU,SAAS,eAAe;AACxC,aAAM,SAAQ,WAAW,SAAS;AAAG,iBAAQ,WAAW,GAAG;AAC3D,wBAAkB,SAAS,OAAO,MAAM,mBAAmB,iBAAgB,UAAS;AACpF,wBAAkB,KAAK,SAAS;AAAA;AAEpC,YAAQ,YAAY;AACpB,eAAU,eAAe,OAAO,KAAK,OAAM;AACvC,YAAM,SAAS,SAAS,cAAc;AACtC,aAAO,QAAQ;AACf,aAAO,WAAW,eAAe;AACjC,aAAO,YAAY;AACnB,eAAS,YAAY;AAAA;AAGzB,UAAM,cAAc,SAAS,cAAc;AAC3C,gBAAY,YAAY;AACxB,gBAAY,UAAU;AACtB,YAAQ,YAAY;AAEpB,UAAM,aAAa,SAAS,cAAc;AAC1C,eAAW,YAAY;AACvB,eAAW,UAAU;AACrB,YAAQ,YAAY;AAEpB,eAAU,QAAQ,SAAQ,OAAM;AAC5B,UAAG,KAAK,KAAK,QAAQ,QAAM,MAAM,KAAK,KAAK,QAAQ,cAAY,KAAK,KAAK,KAAK,QAAQ,aAAW,KAAK,KAAK,KAAK,QAAQ,eAAa,MAAM,KAAK,KAAK,QAAQ,cAAY;AAAI;AAC7K,UAAI,SAAS,SAAS,cAAc;AACpC,aAAO,YAAY,KAAK;AACxB,aAAO,UAAU,MAAM,gBAAe;AACtC,cAAQ,YAAY;AAAA;AAAA;;;ACxDrB,uBAAuB;AAAA,IAO1B,YAAY,OAAoB;AAJhC,yBAAkB;AAKd,WAAK,OAAO,MAAM;AAClB,WAAK,KAAK,MAAM;AAChB,WAAK,cAAc,MAAM;AACzB,WAAK,UAAU,MAAM;AAAA;AAAA,QAId,QAAO;AACd,aAAO,KAAK,QAAQ;AAAA;AAAA,IAIjB,MAAM,QAAa,UAAiD;AAAA;AAAA,IAKpE,KAAK,QAAa,MAAe,UAA4D;AAAA;AAAA;;;ACjBjG,+BAAuB,SAAQ;AAAA,IAelC,YAAY,OAAoB;AAC5B,YAAM,iCACC,QADD;AAAA,QAEF,SAAS,MAAM,MAAM;AAAA,QACrB,IAAI,GAAG,MAAM,MAAM,MAAM,MAAM,MAAM,UAAU;AAAA;AAGnD,WAAK,WAAW,MAAM;AACtB,WAAK,WAAW,MAAM;AACtB,WAAK,WAAW,MAAM;AACtB,WAAK,UAAU,MAAM;AACrB,WAAK,QAAQ,MAAM;AAInB,WAAK,QAAQ,MAAM;AACnB,WAAK,QAAQ,KAAK,MAAM,UAAU;AAAA;AAAA,QAI3B,OAAyB;AAzDxC;AA0DQ,YAAM,OAAO,WAAK,MAAM,SAAX,mBAAiB,UAAU,KAAK;AAC7C,aAAO,8BAAM,aAAU,KAAK,WAAW,OAAO;AAAA;AAAA,QAIvC,OAAyB;AA/DxC;AAgEQ,YAAM,OAAO,WAAK,MAAM,SAAX,mBAAiB,UAAU,KAAK;AAC7C,aAAO,8BAAM,aAAU,KAAK,WAAW,OAAO;AAAA;AAAA,QAIvC,OAAe;AACtB,YAAM;AAAA;AAAA,IAIH,KAAK,QAAa,MAAe,UAAiE;AACrG,WAAK,QAAQ,MAAM,KAAK,KAAK,MAAM,QAAO,MAAM;AAAA;AAAA,IAI7C,MAAM,QAAa,UAAiD;AACvE,eAAS,MAAM;AAAA;AAAA;;;AC/EhB,mBAAiB,GAAU,GAAS;AACvC,WAAO,IAAI,IAAI,KAAK,MAAM,IAAE;AAAA;;;ACsBzB,mCAA2B,SAAQ;AAAA,IAMtC,YAAY,OAAwB;AAChC,YAAM;AACN,WAAK,YAAY,MAAM;AACvB,WAAK,sBAAsB,MAAM;AAAA;AAAA,QAI1B,OAAM;AACb,aAAO,KAAK,QAAQ,YAAY,KAAK;AAAA;AAAA,IAIlC,KAAK,QAAa,MAAe,UAAiE;AACrG,UAAG,KAAK,UAAU,QAAQ,WAAU;AAChC,iBAAQ,KAAK,UAAU,aAAa,QAAQ,QAAO;AAAA;AAEvD,WAAK,QAAQ,MAAM,KAAK,KAAK,MAAM,QAAO,MAAM;AAAA;AAAA,IAI7C,MAAM,QAAa,UAAiD;AACvE,UAAG,KAAK,UAAU,QAAQ,WAAU;AAChC,iBAAQ,KAAK,UAAU,aAAa,QAAQ,QAAO;AAAA;AAEvD,eAAS,MAAM;AAAA;AAAA;;;AC7ChB,qCAA6B,SAAQ;AAAA,IAExC,YAAY,OAA0B;AAClC,YAAM;AAAA;AAAA,QAIC,OAAM;AACb,aAAO,KAAK,QAAQ,cAAc,KAAK;AAAA;AAAA;;;ACCxC,4BAAoB,SAAQ;AAAA,IAU/B,YAAY,OAAiB;AACzB,YAAM,iCACC,QADD;AAAA,QAEF,IAAI,GAAG,MAAM,MAAM,MAAM,MAAM;AAAA,QAC/B,SAAS,MAAM,MAAM;AAAA;AAT7B,uBAA+C;AAY3C,WAAK,QAAQ,MAAM;AACnB,WAAK,QAAQ,MAAM;AACnB,WAAK,YAAY,MAAM,aAAa;AAAA;AAAA,IAIjC,mBAAmB,OAAuC;AAC7D,YAAM,eAAe,IAAI,aAAa,iCAAI,QAAJ,EAAW,OAAM;AACvD,WAAK,UAAU,KAAK;AACpB,aAAO;AAAA;AAAA,IAIJ,qBAAqB,OAAyC;AACjE,YAAM,iBAAiB,IAAI,eAAe,iCAAI,QAAJ,EAAW,OAAM;AAC3D,WAAK,UAAU,KAAK;AACpB,aAAO;AAAA;AAAA,IAIJ,KAAK,QAAa,MAAe,UAAkD;AACtF,iBAAU,YAAY,KAAK,WAAU;AACjC,aAAK,QAAQ,MAAM,KAAK,UAAU,QAAO,MAAM;AAAA;AAAA;AAAA,IAKhD,MAAM,QAAa,UAAiD;AACvE,eAAS,MAAM;AACf,iBAAU,YAAY,KAAK,WAAU;AACjC,iBAAS,MAAM,QAAO;AAAA;AAAA;AAAA;;;AC/C3B,4BAAoB,SAAQ;AAAA,IAW/B,YAAY,OAAiB;AACzB,YAAM,iCACC,QADD;AAAA,QAEF,aAAY;AAAA,QACZ,IAAG,GAAG,MAAM,KAAK,MAAM,MAAM;AAAA,QAC7B,SAAS,MAAM,KAAK;AAAA;AAGxB,WAAK,OAAO,MAAM;AAClB,WAAK,OAAO,MAAM;AAClB,WAAK,YAAY,MAAM;AACvB,WAAK,QAAQ,KAAK,KAAK,OAAO;AAC9B,WAAK,SAAS;AACd,WAAK,eAAe;AACpB,WAAK,SAAS;AAAA;AAAA,IAIX,YAAY,OAAgC;AAC/C,YAAM,SAAQ,IAAI,MAAM,iCAAI,QAAJ,EAAW,OAAM;AAGzC,UAAG,KAAK,OAAO,SAAO,KAAK,KAAK,UAAU,QAAM,KAAK,UAAU,eAAe,OAAM;AAAO,cAAM;AAEjG,WAAK,aAAa,OAAM,QAAQ;AAChC,UAAG,OAAM,QAAM,OAAM,cAAc,KAAK;AAAa,aAAK,cAAc,OAAM,QAAM,OAAM;AAC1F,UAAG,OAAM,WAAU;AACf,aAAK,OAAO,KAAK;AAAA;AAErB,WAAK,KAAK,SAAS;AAOnB,UAAG,KAAK,WAAU;AACd,aAAK,UAAU,OAAO;AACtB,eAAM,OAAO,KAAK;AAAA;AAEtB,WAAK,OAAO,KAAK;AACjB,aAAO;AAAA;AAAA,QAIA,YAAW;AAClB,aAAO,KAAK,OAAO,KAAK,OAAO,SAAO;AAAA;AAAA,QAI/B,aAAY;AACnB,aAAO,KAAK,OAAO;AAAA;AAAA,IAIhB,WAAW,QAAY;AAE1B,eAAQ,QAAQ,QAAO,KAAK;AAC5B,iBAAU,YAAY,KAAK,QAAO;AAC9B,YAAG,SAAS,SAAO,UAAS,SAAS,QAAM,SAAS,cAAc;AAClE,iBAAO;AAAA;AAEX,aAAO;AAAA;AAAA,IAIJ,KAAK,QAAa,MAAe,UAAiE;AACrG,UAAI,WAAW,KAAK,WAAW;AAC/B,UAAG,YAAU,MAAK;AACd,aAAK,QAAQ,MAAM,KAAK,UAAU,QAAO,MAAM;AAAA;AAAA;AAAA,IAKhD,MAAM,QAAa,UAAiD;AACvE,eAAS,MAAM;AACf,UAAI,WAAW,KAAK,WAAW;AAC/B,UAAG,YAAU,MAAK;AACd,iBAAS,MAAM,QAAO;AAAA;AAAA;AAAA;;;ACjG3B,2BAAmB,SAAQ;AAAA,IAQ9B,YAAY,OAAgB;AACxB,YAAM,iCACC,QADD;AAAA,QAEF,aAAY;AAAA,QACZ,IAAG,GAAG,MAAM,QAAQ,cAAc,MAAM;AAAA;AAG5C,WAAK,SAAS;AACd,WAAK,aAAa;AAClB,WAAK,eAAe;AACpB,WAAK,aAAa;AAAA;AAAA,IAIf,YAAY,OAA+B;AAC9C,YAAM,QAAQ,IAAI,MAAM,iCAAI,QAAJ,EAAW,MAAK;AACxC,WAAK,OAAO,KAAK;AACjB,WAAK,WAAW,MAAM,MAAM;AAC5B,WAAK,aAAa,MAAM,QAAQ;AAChC,UAAG,MAAM,cAAc,KAAK;AAAa,aAAK,cAAc,MAAM;AAElE,aAAO;AAAA;AAAA,IAIJ,SAAS,QAAY;AACxB,WAAK,WAAW,OAAM,MAAM;AAC5B,UAAG,OAAM,MAAM,cAAc,KAAK;AAAa,aAAK,cAAc,OAAM,MAAM;AAAA;AAAA,IAI3E,KAAK,QAAa,MAAe,UAA4D;AAChG,iBAAU,SAAS,KAAK,QAAO;AAC3B,YAAG,MAAM,eAAa;AAAG;AACzB,YAAI,IAAI,QAAQ,QAAO,MAAM;AAC7B,YAAG,MAAM,eAAa,GAAE;AACpB,eAAK,QAAQ,MAAM,KAAK,OAAO,QAAO,MAAM;AAAA;AAAA;AAAA;AAAA,IAMjD,MAAM,QAAa,UAAiD;AACvE,eAAS,MAAM;AACf,iBAAU,SAAS,KAAK,QAAO;AAC3B,YAAG,MAAM,eAAa;AAAG;AACzB,YAAI,IAAI,QAAQ,QAAO,MAAM;AAC7B,YAAG,MAAM,eAAa;AAAG,gBAAM,MAAM,QAAO;AAAA;AAAA;AAAA;;;AC9DjD,mBAAW;AAAA,IAOd,YAAY,OAAyB;AACjC,WAAK,IAAI,MAAM;AACf,WAAK,IAAI,MAAM;AACf,WAAK,OAAO,IAAI,aAAa,CAAC,KAAK,GAAG,KAAK;AAAA;AAAA;;;ACZ5C,uBAAc;AAAA,IAWjB,YAAY,GAAU,GAAU,GAAU,GAAU,GAAU,GAAS;AACnE,WAAK,IAAI;AACT,WAAK,IAAI;AACT,WAAK,IAAI;AACT,WAAK,IAAI;AACT,WAAK,IAAI;AACT,WAAK,IAAI;AAET,WAAK,OAAO,IAAI,aAAa,CAAC,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK;AAAA;AAAA;;;ACF5E,6BAAqB,SAAQ;AAAA,IAQhC,YAAY,OAAkB;AAC1B,YAAM,iCACC,QADD;AAAA,QAEF,aAAY;AAAA,QACZ,SAAQ,MAAM,MAAM;AAAA,QACpB,IAAG,GAAG,MAAM,MAAM,QAAQ,gBAAgB,MAAM;AAAA;AAEpD,WAAK,IAAI,MAAM;AACf,WAAK,IAAI,MAAM;AACf,WAAK,QAAQ,MAAM;AACnB,WAAK,SAAS,MAAM;AACpB,WAAK,UAAU,MAAM;AACrB,WAAK,QAAQ,MAAM;AAAA;AAAA,IAIhB,KAAK,QAAa,MAAe,UAA4D;AAAA;AAAA,IAK7F,MAAM,QAAa,UAAiD;AACvE,eAAS,MAAM;AAAA;AAAA;;;AChChB,oBAAW;AAAA,IAad,YAAY,OAAiB;AACzB,WAAK,UAAU;AACf,WAAK,UAAU,MAAM;AACrB,WAAK,QAAQ,MAAM;AACnB,WAAK,MAAM,MAAM;AACjB,WAAK,UAAU,MAAM;AACrB,WAAK,YAAY,MAAM;AACvB,WAAK,SAAS,MAAM;AACpB,WAAK,OAAO,MAAM;AAClB,WAAK,aAAa,MAAM;AAAA;AAAA;;;ACpChC,MAAM,OAA8B;AAAA,IAIhC,QAAQ;AAAA,IACR,SAAS;AAAA,IACT,OAAO;AAAA,IAGP,WAAW;AAAA,IACX,uBAAuB;AAAA,IACvB,kBAAkB;AAAA,IAClB,QAAQ;AAAA,IACR,WAAW;AAAA,IACX,eAAe;AAAA,IACf,YAAY;AAAA,IACZ,YAAY;AAAA,IACZ,YAAY;AAAA,IACZ,QAAQ;AAAA,IACR,UAAU;AAAA,IACV,UAAU;AAAA,IACV,UAAU;AAAA,IACV,SAAS;AAAA,IACT,mBAAmB;AAAA,IACnB,iBAAiB;AAAA,IACjB,aAAa;AAAA,IACb,SAAS;AAAA,IACT,UAAU;AAAA,IAIV,iBAAiB;AAAA,IAGjB,eAAe;AAAA,IACf,aAAa;AAAA,IAGZ,IAAI;AAAA,IACJ,IAAI;AAAA,IACJ,KAAK;AAAA,IACL,IAAI;AAAA,IACJ,GAAG;AAAA,IACH,IAAI;AAAA,IACJ,GAAG;AAAA,IACH,IAAI;AAAA,IACJ,IAAI;AAAA,IACJ,KAAK;AAAA,IACL,GAAG;AAAA,IACH,IAAI;AAAA,IACJ,GAAG;AAAA,IACH,IAAI;AAAA,IACJ,IAAI;AAAA,IACJ,KAAK;AAAA,IACL,IAAI;AAAA,IACJ,GAAG;AAAA,IACH,GAAG;AAAA,IACH,KAAK;AAAA,IACL,GAAG;AAAA,IACH,IAAI;AAAA,IACJ,IAAI;AAAA,IACJ,IAAI;AAAA,IACJ,IAAI;AAAA,IACJ,IAAI;AAAA,IACJ,KAAK;AAAA;AAIV,wBAAsB,KAAW;AAC7B,WAAO,KAAK,QAAQ;AAAA;AAOjB,yBAAuB,MAAa;AACvC,QAAG,OAAO,QAAQ,YAAY,OAAO,QAAQ;AAAU,aAAO;AAC9D,YAAO,OAAO;AAAA,WACL;AAAU,eAAO;AAAA,WACjB;AAAU,eAAO;AAAA,WACjB;AAAW,eAAO;AAAA,WAClB;AACD,YAAG,MAAM,QAAQ,OAAM;AACnB,iBAAQ,KAAoB,IAAI;AAAA,eAC/B;AACD,cAAI,SAAa;AACjB,iBAAO,KAAK,MAAM,QAAQ,SAAO,OAAO,aAAa,QAAQ,cAAc,KAAK;AAChF,iBAAO;AAAA;AAAA,WAEV;AAAU,cAAM;AAAA,WAChB;AAAY,cAAM;AAAA,WAClB;AAAU,cAAM;AAAA,WAChB;AAAa,cAAM;AAAA;AACf,cAAM;AAAA;AAAA;;;AC/FhB,uBAAc;AAAA,IAUjB,YACI,KAAY,KAAY,KAAY,KACpC,KAAY,KAAY,KAAY,KACpC,KAAY,KAAY,KAAY,KACpC,KAAY,KAAY,KAAY,KACvC;AACG,WAAK,MAAI;AAAK,WAAK,MAAI;AAAK,WAAK,MAAI;AAAK,WAAK,MAAI;AACnD,WAAK,MAAI;AAAK,WAAK,MAAI;AAAK,WAAK,MAAI;AAAK,WAAK,MAAI;AACnD,WAAK,MAAI;AAAK,WAAK,MAAI;AAAK,WAAK,MAAI;AAAK,WAAK,MAAI;AACnD,WAAK,MAAI;AAAK,WAAK,MAAI;AAAK,WAAK,MAAI;AAAK,WAAK,MAAI;AAEnD,WAAK,OAAO,IAAI,aAAa;AAAA,QACzB;AAAA,QAAK;AAAA,QAAK;AAAA,QAAK;AAAA,QACf;AAAA,QAAK;AAAA,QAAK;AAAA,QAAK;AAAA,QACf;AAAA,QAAK;AAAA,QAAK;AAAA,QAAK;AAAA,QACf;AAAA,QAAK;AAAA,QAAK;AAAA,QAAK;AAAA;AAAA;AAAA;;;ACVpB,sBAAa;AAAA,IAYhB,YAAY,MAAa,MAAa,QAAY;AARlD,mBAAoB;AACpB,yBAAmC;AACnC,2BAAuC;AACvC,qBAAuB;AACvB,iCAA4C;AAKxC,WAAK,OAAO;AACZ,WAAK,OAAO;AACZ,WAAK,UAAU;AACf,WAAK,QAAQ;AAAA;AAAA,IAIjB,OAAO,MAAY;AACf,UAAG,KAAK,YAAY;AAAO,eAAO,KAAK,YAAY;AACnD,UAAG,KAAK,cAAc;AAAO,eAAO,KAAK,cAAc;AACvD,YAAM,yBAAyB,OAAO,mBAAmB,KAAK;AAAA;AAAA,IAIlE,YAAY,OAAkC;AAC1C,YAAM,QAAQ,IAAI,MAAM,iCAAI,QAAJ,EAAW,SAAQ;AAC3C,WAAK,QAAQ,KAAK;AAClB,aAAO;AAAA;AAAA,IAIX,aAAa,OAAa,OAAiC;AACvD,YAAM,SAAS,IAAI,OAAO,iCAAI,QAAJ,EAAW;AACrC,YAAM,QAAQ,KAAK;AACnB,WAAK,cAAc,OAAO,QAAQ;AAClC,WAAK,oBAAoB,OAAO,QAAQ;AACxC,aAAO;AAAA;AAAA,IAIX,WAAW,OAAiC;AACxC,YAAM,OAAO,IAAI,KAAK,iCAAI,QAAJ,EAAW,SAAQ;AACzC,WAAK,MAAM,KAAK;AAChB,WAAK,YAAY,KAAK,QAAQ;AAC9B,aAAO;AAAA;AAAA,IAIE,WAAU;AAAA;AACnB,cAAM,eAAe,KAAK,OAAO;AACjC,cAAM,kBAAkB,MAAM,MAAM;AACpC,cAAM,UAAwB,MAAM,gBAAgB;AACpD,cAAM,OAAO,cAAc;AAC3B,cAAM,cAA4B;AAGlC,mBAAU,cAAc,KAAK,iBAAiB,SAAQ;AAClD,gBAAM,OAAO,KAAK,WAAW;AAAA,YACzB,MAAM,WAAW;AAAA;AAIrB,mBAAQ,IAAE,WAAW,SAAS,OAAO,SAAO,GAAG,KAAG,GAAG,KAAI;AACrD,kBAAM,YAAY,WAAW,SAAS,OAAO;AAC7C,kBAAM,QAAQ,KAAK,YAAY;AAAA,cAC3B,MAAM,UAAU;AAAA,cAChB,MAAM,UAAU,aAAa;AAAA,cAC7B,WAAW,UAAU,aAAa;AAAA;AAItC,uBAAU,aAAa,UAAU,QAAO;AACpC,oBAAM,SAAQ,MAAM,YAAY;AAAA,gBAC5B,MAAM,KAAG,UAAU;AAAA,gBACnB,aAAa,UAAU;AAAA,gBACvB,WAAW,UAAU;AAAA,gBACrB,OAAO,UAAU;AAAA;AAIrB,yBAAU,oBAAqB,UAAU,UAAS;AAC9C,oBAAG,oBAAoB,kBAAiB;AAIpC,wBAAM,WAAW,iBAAiB;AAClC,wBAAM,IAAI,SAAS;AAEnB,wBAAM,gBAA+B;AAAA,oBACjC,MAAM,OAAM;AAAA,oBACZ,aAAa,OAAM;AAAA;AAGvB,wBAAM,gBAAgC;AAAA,oBAClC;AAAA,oBACA,SAAS,SAAS,WAAW;AAAA,oBAC7B,UAAU,SAAS,IAAI,IAAI,SAAS,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,OAAO,IAAI,SAAS,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE;AAAA,oBAC9H,UAAU,SAAS,IAAI,IAAI,SAAS,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KACvB,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KACvB,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KACvB,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,OACpC,IAAI,SAAS,EAAG,IAAI,EAAG,IAAI,EAAG,IAAI,EAAG,IACxB,EAAG,IAAI,EAAG,IAAI,EAAG,IAAI,EAAG,IACxB,EAAG,IAAI,EAAG,IAAI,EAAE,KAAK,EAAE,KACvB,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE;AAAA,oBAC3D,UAAU,SAAS;AAAA,oBACnB,OAAO,SAAS,SAAS;AAAA;AAM7B,wBAAM,eAAe,OAAM,mBAAmB,gDACvC,gBACA,gBAFuC;AAAA,oBAG1C,qBAAqB,IAAI,KAAK,SAAS;AAAA,oBACvC,WAAW,SAAS,cAAc,YACvB,EAAE,MAAM,WAAW,MAAM,SAAS,MAAM,YAAY,SAAS,eAC7D,EAAE,MAAM;AAAA;AAAA,uBAEtB;AAID,wBAAM,WAAW,iBAAiB;AAClC,wBAAM,IAAI,SAAS;AAEnB,wBAAM,gBAA+B;AAAA,oBACjC,MAAM,OAAM;AAAA,oBACZ,aAAa,OAAM;AAAA;AAGvB,wBAAM,gBAAgC;AAAA,oBAClC;AAAA,oBACA,SAAS,SAAS,WAAW;AAAA,oBAC7B,OAAO;AAAA,oBACP,UAAU,SAAS,IAAI,IAAI,SAAS,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,OAAO,IAAI,SAAS,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE;AAAA,oBAC9H,UAAU,SAAS,IAAI,IAAI,SAAS,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KACvB,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KACvB,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KACvB,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,OACpC,IAAI,SAAS,EAAG,IAAI,EAAG,IAAI,EAAG,IAAI,EAAG,IACxB,EAAG,IAAI,EAAG,IAAI,EAAG,IAAI,EAAG,IACxB,EAAG,IAAI,EAAG,IAAI,EAAE,KAAK,EAAE,KACvB,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE;AAAA,oBAC3D,UAAU,SAAS;AAAA;AAMvB,wBAAM,iBAAiB,OAAM,qBAAqB,kCAC3C,gBACA;AAGP,sBAAG,YAAY,QAAQ,eAAe,aAAW;AAAI,gCAAY,KAAK,eAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAKxG;AAGD,YAAI,oBAAoB;AACxB,mBAAU,cAAc,aAAY;AAChC,cAAG,KAAK,oBAAoB,eAAa,MAAK;AAC1C,kBAAM,iBAAiB,KAAK,OAAO,aAAa;AAChD,kBAAM,aAAa,MAAM,MAAM;AAC/B,kBAAM,WAAwB,MAAM,WAAW;AAC/C,kBAAM,QAAO,cAAc;AAE3B,kBAAM,QAAQ,IAAI,MAAM,MAAK,KAAK,KAAK,GAAG,MAAK,KAAK,KAAK;AACzD,kBAAM,MAAM,KAAK,OAAO,aAAa;AAGrC,kBAAM,QAAQ,KAAK,YAAY;AAAA,cAC3B;AAAA,cACA,KAAK,MAAK,KAAK;AAAA,cACf,SAAS,MAAK,KAAK;AAAA,cACnB,WAAW,MAAK,KAAK;AAAA,cACrB,QAAQ,MAAK,KAAK;AAAA,cAClB,MAAM,MAAK,KAAK;AAAA,cAChB,YAAY,MAAK,KAAK;AAAA;AAE1B,uBAAU,oBAAoB,MAAK,MAAM,SAAQ;AAC7C,oBAAM,aAAa,iBAAiB;AACpC,oBAAM,SAAS,KAAK,aAAa,OAAO;AAAA,gBACpC,MAAM,WAAW;AAAA,gBACjB,GAAG,WAAW;AAAA,gBACd,GAAG,WAAW;AAAA,gBACd,OAAO,WAAW;AAAA,gBAClB,QAAQ,WAAW;AAAA,gBACnB,SAAS,WAAW;AAAA;AAExB,mBAAK,oBAAoB,OAAO,QAAQ;AAAA;AAI5C;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACtNT,oBAAoB;AAAA,IAKvB,cAAa;AACT,WAAK,OAAO;AAAA;AAAA,QAIZ,SAAe;AACf,YAAM;AAAA;AAAA,QAIN,SAAe;AACf,YAAM;AAAA;AAAA,IAIV,cAAc,MAAa,MAAY;AACnC,YAAM,WAAU,IAAI,QAAQ,MAAM,MAAM;AACxC,aAAO;AAAA;AAAA;;;ACVR,oCAA4B,MAAK;AAAA,IAUpC,YAAY,KAA6B;AACrC;AAwDJ,kBAAO,CAAC,MAAe,QAAa,MAAe,aAAgE;AAC/G,YAAG,gBAAgB,OAAM;AACtB,cAAG,KAAK,QAAM,WAAU;AAAA,qBACf,KAAK,WAAU;AACnB,kBAAM,YAAY,KAAK,KAAK,aAAa,KAAK;AAC9C,iBAAK;AACL,sBAAU,KAAK,QAAO,MAAM;AAC5B,iBAAK,IAAI,2BAA2B;AACpC,gBAAG;AAAU,uBAAS,MAAM,QAAO;AAAA;AAC9B,mBAAK,KAAK,QAAO,MAAM;AAC5B,iBAAK;AAAA,iBACJ;AACD,gBAAG;AAAU,uBAAS,MAAM,QAAO;AAAA;AAC9B,mBAAK,KAAK,QAAO,MAAM;AAAA;AAAA,mBAE3B,gBAAgB,UAAS;AAC9B,eAAK,IAAI;AACT,eAAK,kBAAkB,MAAM,QAAO;AACpC,gBAAM,iBAAiB,KAAK,cAAc,MAAM,QAAO;AACvD,eAAK,YAAY,MAAM,QAAO;AAC9B,cAAG;AAAU,qBAAS,MAAM,QAAO;AAAA;AAC9B,iBAAK,KAAK,QAAO,MAAM;AAC5B,cAAG;AAAgB,iBAAK;AACxB,eAAK,IAAI;AAAA,mBACJ,gBAAgB,QAAO;AAC5B,cAAG;AAAU,qBAAS,MAAM,QAAO;AACnC,eAAK,IAAI,UAAU,KAAK,MAAM,OAAO,KAAK,GAAG,KAAK,GAAG,KAAK,OAAO,KAAK,QAAQ,GAAG,GAAG,KAAK,OAAO,KAAK;AAAA,eACpG;AACD,cAAG;AAAU,qBAAS,MAAM,QAAO;AAAA;AAC9B,iBAAK,KAAK,QAAO,MAAM;AAAA;AAAA;AApFhC,WAAK,SAAS,IAAI;AAClB,WAAK,QAAQ,CAAC;AACd,WAAK,OAAO;AAEZ,WAAK,UAAU;AACf,WAAK,UAAU;AACf,UAAI,OAAO,iBAAiB,aAAa,KAAK,YAAY,KAAK;AAAA;AAAA,IAInE,YAAY,GAAa;AACrB,YAAM,OAAO,KAAK,OAAO;AACzB,YAAM,SAAS,KAAK,OAAO,QAAQ,KAAK;AACxC,YAAM,SAAS,KAAK,OAAO,SAAS,KAAK;AACzC,WAAK,UAAW,GAAE,UAAU,KAAK,QAAQ;AACzC,WAAK,UAAW,GAAE,UAAU,KAAK,OAAO;AACxC,cAAQ,IAAI,KAAK,SAAS,KAAK;AAAA;AAAA,QAI/B,SAAQ;AACR,aAAO;AAAA;AAAA,QAIP,SAAQ;AACR,aAAO;AAAA;AAAA,QAIP,MAAK;AACL,aAAO,KAAK,MAAM,KAAK,MAAM,SAAO;AAAA;AAAA,IAIxC,mBAAkB;AACd,YAAM,MAAM,KAAK,KAAK,UAAQ,IAAI,SAAS,cAAc,UAAU,WAAW,QAAS,KAAK,KAAK;AACjG,UAAI,OAAO,QAAQ,KAAK,IAAI,OAAO;AACnC,UAAI,OAAO,SAAS,KAAK,IAAI,OAAO;AACpC,UAAI,aAAa,KAAK,IAAI;AAC1B,WAAK,MAAM,KAAK;AAAA;AAAA,IAIpB,kBAAiB;AACb,UAAG,KAAK,MAAM,UAAQ;AAAG,cAAM;AAC/B,YAAM,MAAM,KAAK,MAAM;AACvB,WAAK,IAAI;AACT,WAAK,IAAI;AACT,WAAK,IAAI,UAAU,IAAK,QAAQ,GAAG;AACnC,WAAK,IAAI;AACT,WAAK,KAAK,KAAK;AAAA;AAAA,IAsCX,YAAY,MAAe,QAAa,MAAc;AArHlE;AAuHQ,UAAG,YAAK,UAAL,mBAAY,SAAQ,QAAQ,YAAK,UAAL,mBAAY,SAAQ,WAAW,YAAK,UAAL,mBAAY,SAAQ,cAAc,YAAK,UAAL,mBAAY,SAAQ;AAAM,aAAK,IAAI,eAAe,KAAK,MAAM;AAAA;AAAA,IAIzJ,cAAc,MAAe,QAAa,MAAc;AAE5D,UAAG,KAAK,SAAQ;AACZ,iBAAQ,KAAK,OAAO,KAAK,KAAK,UAAS;AACnC,gBAAM,MAAM;AACZ,cAAG,OAAK,oBAAmB;AACvB,kBAAM,SAAS,KAAK,QAAQ;AAC5B,iBAAK,eACD,OAAO,QAAS,KAAK,MAAM,OAAO,WAAS,KAAM,SAAS,KAC1D,OAAO,OACP,KAAK,IAAI,OAAO,QAAM,KAAK,KAAG,OAAO,OAAO,UAC5C,KAAK,IAAI,OAAO,QAAM,KAAK,KAAG,OAAO,OAAO;AAEhD,mBAAO;AAAA;AAAA;AAAA;AAAA;AAAA,IAOvB,eAAe,OAAc,MAAa,UAAc,GAAG,UAAc,GAAE;AACvE,WAAK,IAAI,cAAc;AACvB,WAAK,IAAI,aAAa;AACtB,WAAK,IAAI,gBAAgB;AACzB,WAAK,IAAI,gBAAgB;AACzB,WAAK;AAAA;AAAA,IAIT,gBAAe;AACX,WAAK;AAAA;AAAA,IAID,kBAAkB,MAAe,QAAa,MAAc;AAChE,UAAG,QAAQ,KAAK,MAAK;AACjB,cAAM,IAAK,SAAQ,QAAO,KAAK,eAAa,KAAK,SAAS,KAAK,MAAM;AACrE,cAAM,KAAK,KAAK;AAChB,cAAM,KAAK,KAAK,KAAK;AACrB,aAAK,IAAI,UACL,GAAG,IAAK,IAAG,IAAE,GAAG,KAAG,GACnB,GAAG,IAAK,IAAG,IAAE,GAAG,KAAG,GACnB,GAAG,IAAK,IAAG,IAAE,GAAG,KAAG,GACnB,GAAG,IAAK,IAAG,IAAE,GAAG,KAAG,GACnB,GAAG,IAAK,IAAG,IAAE,GAAG,KAAG,GACnB,GAAG,IAAK,IAAG,IAAE,GAAG,KAAG;AAAA,aAEtB;AACD,aAAK,IAAI,UAAU,KAAK,SAAS,GAAG,KAAK,SAAS,GAAG,KAAK,SAAS,GAAG,KAAK,SAAS,GAAG,KAAK,SAAS,GAAG,KAAK,SAAS;AAAA;AAAA;AAAA;;;ACrKlI,MAAM,SAAS,SAAS,eAAe;AACvC,MAAM,QAAQ,OAAO,WAAW;AAChC,MAAI,MAAM,YAAY;AAGtB,MAAM,QAAQ,IAAI,cAAc;AAChC,MAAM,YAAY;AAAA,IACd,MAAM,MAAM,cAAc,QAAQ;AAAA,IAClC,UAAU,MAAM,cAAc,YAAY;AAAA;AAI9C,kBAAqB;AAAA;AAEjB,YAAM,UAAU,KAAK;AACrB,YAAM,UAAU,SAAS;AACzB;AAAA;AAAA;AAKJ,MAAI,QAAQ;AACZ,MAAI,UAAU,UAAU,OAAO,KAAK,WAAW;AAC/C,MAAI,SAAQ,QAAQ,MAAM;AAC1B,MAAI,cAAc;AAGlB,MAAM,iBAAiB,CAAC,eAAoB,SAAO;AACnD,MAAM,UAAW,MAAM;AAAE,QAAG,cAAc;AAAG;AAAA;AAC7C,MAAM,SAAU,MAAM;AACtB,MAAM,mBAAmB,CAAC,gBAAwB;AAC9C,cAAU;AACV,aAAS,QAAQ,MAAM;AAAA;AAG3B,oBAAkB,OAAO,KAAK,WAAW,IAAI,WAAW,kBAAkB,gBAAgB,SAAS;AAGnG,oBAAiB;AACb,UAAM,IAAI,YAAY;AACtB,UAAM,IAAI,SAAS,GAAG,GAAG,OAAO,OAAO,OAAO;AAE9C,UAAM,IAAI;AAEN,UAAM,IAAI,UAAU,OAAO,QAAM,GAAG,OAAO,SAAO;AAClD,UAAM,IAAI,MAAM,KAAK;AAErB,UAAM,MAAM,cAAY;AACxB,QAAI,KAAK,OAAO,QAAM,MAAI;AAC1B,QAAI,KAAK,OAAO,SAAO,MAAI;AAE3B,aAAQ,IAAI,GAAG,IAAI,KAAK,KAAI;AACxB,eAAQ,IAAI,GAAG,IAAI,KAAK,KAAI;AACxB,cAAM,IAAI;AACN,cAAM,IAAI,UAAU,CAAE,OAAI,KAAG,KAAG,IAAE,IAAI,CAAE,OAAI,KAAG,KAAG,IAAE;AACpD,eAAO,KAAK;AAChB,cAAM,IAAI;AAAA;AAAA;AAItB,UAAM,IAAI;AAEV;AACA,0BAAsB;AAAA;AAI1B;",
  "names": []
}
