{
  "version": 3,
  "sources": ["../src/examples/example-utils.ts", "../src/core/Drawable.ts", "../src/core/Instance.ts", "../src/core/util.ts", "../src/core/ClipInstance.ts", "../src/core/SpriteInstance.ts", "../src/core/Frame.ts", "../src/core/Layer.ts", "../src/core/Clip.ts", "../src/core/geom/Vec2.ts", "../src/core/geom/Matrix2d.ts", "../src/core/Sprite.ts", "../src/core/Atlas.ts", "../src/core/json/utilJson.ts", "../src/core/Library.ts", "../src/core/AnimationContext.ts", "../src/Canvas2dAnimationContext.ts", "../src/examples/dynamic-content.ts"],
  "sourcesContent": ["import { Clip } from \"../core/Clip\";\nimport { Library } from \"../core/Library\";\n\n\nexport function setupCanvas(canvas:HTMLCanvasElement) {\n    // Set the context quality and smoothing\n    const ctx = canvas.getContext('2d')!\n    ctx.imageSmoothingEnabled = true;\n    ctx.imageSmoothingQuality = 'high'\n\n    // Set the canvas according to window width\n    var bodyRec = document.body.getBoundingClientRect();\n    canvas.width = Math.min(1000, bodyRec.width - 8);\n    canvas.height = canvas.width;\n\n    // Get the device pixel ratio, falling back to 1.\n    let dpr = window.devicePixelRatio || 1;\n\n    // Get the size of the canvas in CSS pixels.\n    let rect = canvas.getBoundingClientRect();\n    \n    // Give the canvas pixel dimensions of their CSS\n    // size * the device pixel ratio.\n    canvas.style.border = \"2px solid gray\";\n    canvas.style.width = \"\" + canvas.width + \"px\";\n    canvas.style.height = \"\" + canvas.height + \"px\";\n    canvas.width = rect.width * dpr;\n    canvas.height = rect.height * dpr;\n\n    return dpr;\n}\n\n\n\nexport function addExampleButtons(libraryKey:string, libs:Record<string, Library>, onLibrarySelected:(nextLibrary:Library)=>void, onSymbolPicked:(nextSymbol:Clip)=>void, onMinus:()=>void, onPlus:()=>void){\n    const library = libs[libraryKey]\n    const buttons = document.getElementById(\"buttons\")!\n\n    const selector = document.createElement('select')\n    selector.value = libraryKey\n    selector.onchange = (e) => {\n        const buttons = document.getElementById('buttons')!\n        while(buttons.childNodes.length > 0) buttons.childNodes[0].remove();\n        addExampleButtons(selector.value, libs, onLibrarySelected, onSymbolPicked, onMinus, onPlus)\n        onLibrarySelected(libs[selector.value])\n    }\n    buttons.appendChild(selector)\n    for(const libraryName of Object.keys(libs)){\n        const option = document.createElement('option')\n        option.value = libraryName\n        option.selected = libraryName == libraryKey\n        option.innerText = libraryName\n        selector.appendChild(option)\n    }\n\n    const minusButton = document.createElement('button')\n    minusButton.innerHTML = '-'\n    minusButton.onclick = onMinus\n    buttons.appendChild(minusButton);\n\n    const plusButton = document.createElement('button')\n    plusButton.innerHTML = '+'\n    plusButton.onclick = onPlus\n    buttons.appendChild(plusButton);\n\n    for(const clip of library.clips){\n        if(clip.name.indexOf(\"/\")!=-1 || clip.name.indexOf(\"Symbol \")==0 || clip.name.indexOf(\"Tween \")==0 || clip.name.indexOf(\"/Symbol \")!=-1 || clip.name.indexOf(\"/Tween \")!=-1) continue;\n        var button = document.createElement(\"button\")\n        button.innerHTML = clip.name\n        button.onclick = () => onSymbolPicked(clip)\n        buttons.appendChild(button)\n    }\n}", "import { Library } from \"./Library\";\n\ntype Int = number;\ntype Float = number;\n\n\nexport type DrawableProps = {\n    name:string,\n    id:string,\n    totalFrames:Int,\n    library:Library;\n}\n\n\nexport abstract class Drawable{\n    name:string;\n    id:string;\n    totalFrames:Int = 1;\n    library:Library;\n\n\n    constructor(props:DrawableProps){\n        this.name = props.name;\n        this.id = props.id;\n        this.totalFrames = props.totalFrames;\n        this.library = props.library;\n    }\n\n\n    public visit(frame:Float, callback:(item:Drawable, frame:Float)=>void):void{\n        // Override in base class\n    }\n\n\n    public draw(frame:Float, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void, lerp?:boolean){\n        // Override in base class\n    }\n\n}", "import { Drawable } from \"./Drawable\";\nimport { Frame } from \"./Frame\";\nimport { Matrix2d } from \"./geom/Matrix2d\";\nimport { Vec3 } from \"./geom/Vec3\";\nimport { DrawableProps } from './Drawable'\n\n\nexport type InstanceProps = Omit<DrawableProps, 'id' | 'library'> & {\n    itemName:string,\n    matrix2d:Matrix2d,\n    frame:Frame,\n    //position:Vec3,\n    //scale:Vec3,\n    //rotation:Vec3,\n}\n\n\nexport class Instance extends Drawable{\n\n    matrix2d:Matrix2d;\n    frame:Frame;\n    index:number;\n    itemName:string;\n    //position:Vec3;\n    //scale:Vec3;\n    //rotation:Vec3;\n    //filters = new Array<Filter>();\n\n    \n    constructor(props:InstanceProps){\n        super({\n            ...props,\n            library: props.frame.library,\n            id: `${props.frame.id}.${props.frame.instances.length}`,\n        });\n\n        this.itemName = props.itemName;\n        this.matrix2d = props.matrix2d;\n        //this.position = props.position;\n        //this.scale = props.scale;\n        //this.rotation = props.rotation;\n        this.frame = props.frame;\n        this.index = this.frame.instances.length;\n    }\n\n\n    public get prev():Instance|undefined{\n        return this.frame.prev?.instances[this.index]\n    }\n\n\n    public get next():Instance|undefined{\n        return this.frame.next?.instances[this.index]\n    }\n\n\n    public get item():Drawable{\n        throw(\"Override item getter in base class\");\n    }\n\n\n    public draw(frame:Float, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void, lerp?:boolean):void{\n        this.library.context.draw(this.item, frame, callback, lerp)\n    }\n\n\n    public visit(frame:Float, callback:(item:Drawable, frame:Float)=>void):void{\n        callback(this, frame)\n    }\n\n}", "\nexport function modWrap(a:number, b:number){\n    return a - b * Math.floor(a/b);\n}\n", "import { Drawable } from \"./Drawable\";\nimport { Vec2 } from \"./geom/Vec2\";\nimport { Instance } from \"./Instance\";\nimport { InstanceProps } from \"./Instance\"\nimport { modWrap } from \"./util\";\n\ntype LoopKind = 'loop' // TODO: HANDLE OTHER LOOP KINDS | 'PlayOnce' | 'SingleFrame' | 'PlayOnceReverse' | 'LoopReverse'\n\n\ntype ClipInstanceBehavior = {\n    type: 'graphic'\n    loop:LoopKind;\n    firstFrame:Float;\n} | {\n    type: 'movieclip'\n}\n\n\nexport type ClipInstanceProps = InstanceProps & { \n    transformationPoint:Vec2,   \n    behaviour:ClipInstanceBehavior\n}\n\n\nexport class ClipInstance extends Instance{\n\n    transformationPoint:Vec2\n    behaviour:ClipInstanceBehavior\n    //color:Null<Color>;\n    \n    \n    constructor(props:ClipInstanceProps){\n        super(props);\n        this.behaviour = props.behaviour;\n        this.transformationPoint = props.transformationPoint;\n    }\n\n\n    public get item(){\n        return this.library.clipsByName[this.itemName];\n    }\n\n\n    public draw(frame:Float, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void, lerp?:boolean):void{\n        if(this.behaviour.type == 'graphic'){\n            frame = this.behaviour.firstFrame + modWrap(frame, 1);\n        }\n        this.library.context.draw(this.item, frame, callback, lerp)\n    }\n\n\n    public visit(frame:Float, callback:(item:Drawable, frame:Float)=>void):void{\n        if(this.behaviour.type == 'graphic'){\n            frame = this.behaviour.firstFrame + modWrap(frame, 1);\n        }\n        callback(this, frame)\n    }\n\n}\n", "import { Instance, InstanceProps } from \"./Instance\";\n\ntype Float = number;\n\nexport type SpriteInstanceProps = InstanceProps & {\n\n}\n\n\nexport class SpriteInstance extends Instance{\n\n    constructor(props:SpriteInstanceProps){\n        super(props)\n    }\n\n    \n    public get item(){\n        return this.library.spritesByName[this.itemName];\n    }\n\n\n}\n", "import { ClipInstance, ClipInstanceProps } from \"./ClipInstance\";\nimport { Drawable } from \"./Drawable\";\nimport { Layer } from \"./Layer\";\nimport { SpriteInstance, SpriteInstanceProps } from \"./SpriteInstance\";\nimport { DrawableProps } from \"./Drawable\";\nimport { Instance } from \"./Instance\";\n\n\ntype Int = number;\n\n\nexport type FrameProps = Omit<DrawableProps, 'id' | 'library'> & {\n    index:Int,\n    layer:Layer,\n    labelName:string|undefined,\n}\n\n\nexport class Frame extends Drawable{\n\n    index:number\n    labelName:string|null;\n    layer:Layer;\n    instances:Array<ClipInstance|SpriteInstance> = [];\n    prev:Frame|undefined;\n    next:Frame|undefined;\n\n\n    constructor(props:FrameProps){\n        super({\n            ...props,\n            id: `${props.layer.id}.${props.index}`,\n            library: props.layer.library\n        });\n        \n        this.layer = props.layer;\n        this.index = props.index;\n        this.labelName = props.labelName || null;\n    }\n\n\n    public createClipInstance(props:Omit<ClipInstanceProps, 'frame'>){\n        const clipInstance = new ClipInstance({...props, frame:this})\n        this.instances.push(clipInstance)\n        return clipInstance;\n    }\n\n\n    public createSpriteInstance(props:Omit<SpriteInstanceProps, 'frame'>){\n        const spriteInstance = new SpriteInstance({...props, frame:this})\n        this.instances.push(spriteInstance)\n        return spriteInstance\n    }\n\n\n    public draw(frame:Float, callback?:(item:Drawable, frame:Float)=>void, lerp?:boolean):void{\n        for(const instance of this.instances){\n            this.library.context.draw(instance, frame, callback, lerp)\n        }\n    }\n\n\n    public visit(frame:Float, callback:(item:Drawable, frame:Float)=>void):void{\n        callback(this, frame)\n        for(const instance of this.instances){\n            instance.visit(frame, callback)\n        }\n    }\n\n}\n", "import { Clip } from \"./Clip\";\nimport { Drawable } from \"./Drawable\";\nimport { Frame, FrameProps } from \"./Frame\";\nimport { DrawableProps } from \"./Drawable\"\nimport { modWrap } from \"./util\";\n\n\ntype Int = number;\ntype Float = number;\n\n\nexport type LayerProps = Omit<DrawableProps, 'totalFrames'|'id'|'library'> & {\n    clip:Clip\n}\n\n\nexport class Layer extends Drawable{\n\n    public index:Int;\n    public frames:Array<Frame>;\n    public framesByName:Record<string, Frame>;\n    public labels:Array<Frame>;\n    public clip:Clip;\n\n\n    constructor(props:LayerProps){\n        super({\n            ...props,\n            totalFrames:0,\n            id:`${props.clip.id}.${props.name}`,\n            library: props.clip.library,\n        });\n        \n        this.clip = props.clip;\n        this.index = this.clip.layers.length;\n        this.frames = [];\n        this.framesByName = {};\n        this.labels = [];\n    }\n\n\n    public createFrame(props:Omit<FrameProps, 'layer'>){\n        const frame = new Frame({...props, layer:this});\n\n        // TODO: Allow for more flexibility when adding frames\n        if(this.frames.length>0 && this.lastFrame.index+this.lastFrame.totalFrames != frame.index) throw(\"Must add next frame at previous frame.index+frame.duration\")\n\n        this.framesByName[frame.name] = frame;\n        if(frame.index+frame.totalFrames > this.totalFrames) this.totalFrames = frame.index+frame.totalFrames\n        if(frame.labelName){\n            this.labels.push(frame);\n        }\n        this.clip.addFrame(frame);\n        if(this.firstFrame){\n            this.firstFrame.prev = frame\n            frame.next = this.firstFrame\n        }\n        if(this.lastFrame){\n            this.lastFrame.next = frame\n            frame.prev = this.lastFrame\n        }\n        this.frames.push(frame)\n        return frame;\n    }\n\n\n    public get lastFrame(){\n        return this.frames[this.frames.length-1];\n    }\n\n\n    public get firstFrame(){\n        return this.frames[0];\n    }\n\n\n    public keyframeAt(frame:Float){\n        // TODO: Binary search would be a good optimisation here\n        frame = modWrap(frame, this.totalFrames);\n        for(const keyframe of this.frames){\n            if(keyframe.index<=frame && keyframe.index+keyframe.totalFrames > frame)\n            return keyframe;\n        }\n        return null;\n    }\n\n\n    public draw(frame:Float, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void, lerp?:boolean):void{\n        var keyframe = this.keyframeAt(frame)\n        if(keyframe!=null){\n            this.library.context.draw(keyframe, frame, callback, lerp);\n        }\n    }\n\n\n    public visit(frame:Float, callback:(item:Drawable, frame:Float)=>void):void{\n        callback(this, frame);\n        var keyframe = this.keyframeAt(frame)\n        if(keyframe!=null){\n            keyframe.visit(frame, callback)\n        }\n    }\n\n}\n", "import { Drawable } from \"./Drawable\";\nimport { Frame } from \"./Frame\";\nimport { Layer, LayerProps } from \"./Layer\";\nimport { DrawableProps } from './Drawable'\nimport { modWrap } from \"./util\";\n\ntype Float = number;\nexport type ClipProps = Omit<DrawableProps, 'totalFrames'|'id'>\n\n\nexport class Clip extends Drawable{\n\n    layers:Array<Layer>;\n    layersById:Record<string, Layer>;\n    layersByName:Record<string, Layer>;\n    framesById:Record<string, Frame>;\n\n\n    constructor(props:ClipProps){\n        super({\n            ...props,\n            totalFrames:0,\n            id:`${props.library.name}.clips.${props.name}`,\n        })\n        \n        this.layers = [];\n        this.layersById = {};\n        this.layersByName = {};\n        this.framesById = {};\n    }\n\n\n    public createLayer(props:Omit<LayerProps, 'clip'>){\n        const layer = new Layer({...props, clip:this});\n        this.layers.push(layer);\n        this.layersById[layer.id] = layer;\n        this.layersByName[layer.name] = layer;\n        if(layer.totalFrames > this.totalFrames) this.totalFrames = layer.totalFrames;\n\n        return layer;\n    }\n\n\n    public addFrame(frame:Frame){\n        this.framesById[frame.id] = frame;\n        if(frame.layer.totalFrames > this.totalFrames) this.totalFrames = frame.layer.totalFrames;\n    }\n\n\n    public draw(frame:Float, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void, lerp?:boolean){\n        for(const layer of this.layers){\n            if(layer.totalFrames==0) continue;\n            var f = modWrap(frame, layer.totalFrames);\n            if(layer.totalFrames>=f){\n                this.library.context.draw(layer, frame, callback, lerp);\n            }\n        }\n    }\n\n\n    public visit(frame:Float, callback:(item:Drawable, frame:Float)=>void):void{\n        callback(this, frame)\n        for(const layer of this.layers){\n            if(layer.totalFrames==0) continue;\n            var f = modWrap(frame, layer.totalFrames);\n            if(layer.totalFrames>=f) layer.visit(frame, callback)\n        }\n    }\n\n\n   \n}", "type Float = number;\n\n\nexport class Vec2 {\n\n    x:Float\n    y:Float\n    data:Float32Array\n\n    \n    constructor(props:{x:Float, y:Float}){\n        this.x = props.x\n        this.y = props.y\n        this.data = new Float32Array([this.x, this.y])\n    }\n    \n}", "\nexport class Matrix2d{\n\n    a:number\n    b:number\n    c:number\n    d:number\n    e:number\n    f:number\n    data:Float32Array\n\n\n    constructor(a:number, b:number, c:number, d:number, e:number, f:number){\n        this.a = a\n        this.b = b\n        this.c = c\n        this.d = d\n        this.e = e\n        this.f = f\n        \n        this.data = new Float32Array([this.a, this.b, this.c, this.d, this.e, this.f])\n    }\n\n}", "import { Drawable } from \"./Drawable\";\nimport { Atlas } from \"./Atlas\";\nimport { DrawableProps } from \"./Drawable\"\n\ntype Int = number;\ntype Float = number;\n\n\nexport type SpriteProps = Omit<DrawableProps, 'totalFrames'|'library'|'id'> & {\n    x:Float,\n    y:Float,\n    width:Float,\n    height:Float,\n    rotated:boolean,\n    atlas:Atlas,\n}\n\n\nexport class Sprite extends Drawable{\n    x:Float;\n    y:Float;\n    width:Float;\n    height:Float;\n    rotated:boolean;\n    atlas:Atlas;\n\n    constructor(props:SpriteProps){\n        super({\n            ...props,\n            totalFrames:1,\n            library:props.atlas.library,\n            id:`${props.atlas.library.name}.sprites.${props.name}`\n        })\n        this.x = props.x;\n        this.y = props.y;\n        this.width = props.width;\n        this.height = props.height;\n        this.rotated = props.rotated;\n        this.atlas = props.atlas;\n    }\n\n\n    public draw(frame:Float, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void, lerp?:boolean){\n        // Override in base class\n    }\n\n\n    public visit(frame:Float, callback:(item:Drawable, frame:Float)=>void):void{\n        callback(this, frame)\n    }\n   \n}\n", "import { Library } from \"./Library\";\nimport { Sprite } from \"./Sprite\";\n\n\nexport type AtlasProps = {\n    library:Library,\n    image:HTMLImageElement,\n    app:string,\n    version:string,\n    imagePath:string,\n    format:string,\n    size:{w:Float, h:Float},\n    resolution:string\n}\n\n\nexport class Atlas{\n    library:Library;\n    sprites:Array<Sprite>;\n    image:HTMLImageElement;\n\n    app:string;\n    version:string;\n    imagePath:string;\n    format:string;\n    size:{w:Float, h:Float};\n    resolution:string;\n\n    \n    constructor(props:AtlasProps){\n        this.sprites = [];\n        this.library = props.library;\n        this.image = props.image;\n        this.app = props.app;\n        this.version = props.version;\n        this.imagePath = props.imagePath;\n        this.format = props.format;\n        this.size = props.size;\n        this.resolution = props.resolution;\n    }\n\n    \n\n}\n", "import { AnimationJson } from \"./AnimationJson\";\n\nconst keys:Record<string, string> = {\n    // fix inconsistent names\n\n    // spritemap.json\n    SPRITE: \"sprite\",\n    SPRITES: \"sprites\",\n    ATLAS: \"atlas\",\n\n    // Animation.json\n    ANIMATION: \"animation\",\n    ATLAS_SPRITE_instance: \"atlasSpriteInstance\",\n    DecomposedMatrix: \"decomposedMatrix\",\n    Frames: \"frames\",\n    framerate: \"frameRate\",\n    Instance_Name: \"instanceName\",\n    Layer_name: \"layerName\",\n    LAYERS: \"layers\",\n    Matrix3D: \"matrix3D\",\n    Position: \"position\",\n    Rotation: \"rotation\",\n    Scaling: \"scaling\",\n    SYMBOL_DICTIONARY: \"symbolDictionary\",\n    SYMBOL_Instance: \"symbolInstance\",\n    SYMBOL_name: \"symbolName\",\n    Symbols: \"symbols\",\n    TIMELINE: \"timeline\",\n \n     // Animation.json optimised\n     AN: \"animation\",\n     AM: \"alphaMultiplier\",\n     ASI: \"atlasSpriteInstance\",\n     BM: \"bitmap\",\n     C: \"color\",\n     DU: \"duration\",\n     E: \"elements\",\n     FF: \"firstFrame\",\n     FR: \"frames\",\n     FRT: \"frameRate\",\n     I: \"index\",\n     IN: \"instanceName\",\n     L: \"layers\",\n     LN: \"layerName\",\n     LP: \"loop\",\n     M3D: \"matrix3D\",\n     MD: \"metadata\",\n     M: \"mode\",\n     N: \"name\",\n     POS: \"position\",\n     S: \"symbols\",\n     SD: \"symbolDictionary\",\n     SI: \"symbolInstance\",\n     SN: \"symbolName\",\n     ST: \"symbolType\",\n     TL: \"timeline\",\n     TRP: \"transformationPoint\",\n};\n\n\nfunction normaliseKey(key:string){\n    return keys[key] || key;\n}\n\n\n\n// AnimateCC exports wildy inconsistent JSON. Normalise the\n// fields to make it easier to work with\nexport function normaliseJson(data:any):any{\n    if(typeof data == \"string\" || typeof data == \"number\") return data\n    switch(typeof data){\n        case \"string\": return data;\n        case \"number\": return data;\n        case \"boolean\": return data;\n        case \"object\":\n            if(Array.isArray(data)){\n                return (data as Array<any>).map(normaliseJson);\n            }else{\n                var result:any = {};\n                Object.keys(data).forEach(key => result[normaliseKey(key)] = normaliseJson(data[key]));\n                return result;\n            }\n        case \"bigint\": throw(\"Not supported\");\n        case \"function\": throw(\"Not supported\");\n        case \"symbol\": throw(\"Not supported\");\n        case \"undefined\": throw(\"Not supported\");\n        default: throw(\"Unsupported\")\n    }\n}\n", "import { AnimationJson } from \"./json/AnimationJson\";\nimport { Clip, ClipProps } from \"./Clip\";\nimport { ClipInstanceProps } from \"./ClipInstance\";\nimport { SpriteInstanceProps } from \"./SpriteInstance\";\nimport { Vec3 } from \"./geom/Vec3\";\nimport { Vec2 } from \"./geom/Vec2\";\nimport { Matrix2d } from \"./geom/Matrix2d\";\nimport { InstanceProps } from \"./Instance\";\nimport { DrawableProps } from \"./Drawable\";\nimport { Sprite, SpriteProps } from \"./Sprite\";\nimport { Atlas, AtlasProps } from \"./Atlas\";\nimport { normaliseJson } from \"./json/utilJson\";\nimport { AnimationContext } from \"./AnimationContext\";\n\n\nexport class Library{\n\n    name:string;\n    path:string;\n    clips:Array<Clip> = [];\n    clipsByName:Record<string, Clip> = {};\n    spritesByName:Record<string, Sprite> = {};\n    atlases:Array<Atlas> = [];\n    atlasesBySpriteName:Record<string, Atlas> = {}\n    context:AnimationContext;\n    \n    \n    constructor(name:string, path:string, context:AnimationContext){\n        this.name = name;\n        this.path = path;\n        this.atlases = [];\n        this.context = context;\n    }\n\n\n    symbol(name:string){\n        if(this.clipsByName[name]) return this.clipsByName[name]\n        if(this.spritesByName[name]) return this.spritesByName[name]\n        throw(\"Cannot find symbol: \" + name + \" for library: \" + this.path);\n    }\n\n\n    createAtlas(props:Omit<AtlasProps, 'library'>){\n        const atlas = new Atlas({...props, library:this});\n        this.atlases.push(atlas);\n        return atlas;\n    }\n\n\n    createSprite(atlas:Atlas, props:Omit<SpriteProps, 'atlas'>){\n        const sprite = new Sprite({...props, atlas:atlas})\n        atlas.sprites.push(sprite);\n        this.spritesByName[sprite.name] = sprite;\n        this.atlasesBySpriteName[sprite.name] = atlas;\n        return sprite;\n    }\n\n\n    createClip(props:Omit<ClipProps, 'library'>){\n        const clip = new Clip({...props, library:this});\n        this.clips.push(clip)\n        this.clipsByName[clip.name] = clip\n        return clip;\n    }\n\n\n    public async loadData(){\n        const animJsonPath = this.path + \"/Animation.json\";\n        const animFetchResult = await fetch(animJsonPath);\n        const dataRaw:AnimationJson = await animFetchResult.json();\n        const data = normaliseJson(dataRaw) as AnimationJson;\n        const spriteNames:Array<string> = [];\n\n        // Clip\n        for(const symbolData of data.symbolDictionary.symbols){\n            const clip = this.createClip({\n                name: symbolData.symbolName,\n            })\n\n            // Layer\n            for(let l=symbolData.timeline.layers.length-1; l>=0; l--){\n                const layerData = symbolData.timeline.layers[l]\n                const layer = clip.createLayer({\n                    name: layerData.layerName,\n                })\n\n                // Frame\n                for(const frameData of layerData.frames){\n                    const frame = layer.createFrame({\n                        name: \"\"+frameData.index,\n                        totalFrames: frameData.duration,\n                        labelName: frameData.name,\n                        index: frameData.index,\n                    })\n\n                    // Element\n                    for(const elemInstanceData of  frameData.elements){\n                        if(\"symbolInstance\" in elemInstanceData){\n                            type _DrawableProps = Pick<DrawableProps, keyof DrawableProps & keyof ClipInstanceProps>;\n                            type _InstanceProps = Omit<InstanceProps, keyof DrawableProps>\n                            \n                            const elemData = elemInstanceData.symbolInstance;\n                            const m = elemData.matrix3D;\n\n                            const drawableProps:_DrawableProps = {\n                                name: frame.name,\n                                totalFrames: frame.totalFrames,\n                            }\n\n                            const instanceProps:_InstanceProps  = {\n                                frame,\n                                matrix2d: 'm00' in m ? new Matrix2d(m.m00, m.m01, m.m10, m.m11, m.m30, m.m31) : new Matrix2d(m[0], m[1], m[4], m[5], m[12], m[13]),\n                                itemName: elemData.symbolName,\n                                //position: new Vec3(elemData.decomposedMatrix.position),\n                                //scale: new Vec3(elemData.decomposedMatrix.scaling),\n                                //rotation: new Vec3(elemData.decomposedMatrix.rotation),\n                            }\n\n                            const clipInstance = frame.createClipInstance({\n                                ...drawableProps,\n                                ...instanceProps,\n                                transformationPoint: new Vec2(elemData.transformationPoint),\n                                behaviour: elemData.symbolType == \"graphic\"\n                                         ? { type: 'graphic', loop: elemData.loop, firstFrame: elemData.firstFrame}\n                                         : { type: 'movieclip' }\n                            })\n                        }else{\n                            type _DrawableProps = Pick<DrawableProps, keyof DrawableProps & keyof SpriteInstanceProps>;\n                            type _InstanceProps = Omit<InstanceProps, keyof DrawableProps>\n                            \n                            const elemData = elemInstanceData.atlasSpriteInstance;\n                            const m = elemData.matrix3D;\n\n                            const drawableProps:_DrawableProps = {\n                                name: frame.name,\n                                totalFrames: frame.totalFrames,\n                            }\n\n                            const instanceProps:_InstanceProps  = {\n                                frame,\n                                matrix2d: 'm00' in m ? new Matrix2d(m.m00, m.m01, m.m10, m.m11, m.m30, m.m31) : new Matrix2d(m[0], m[1], m[4], m[5], m[12], m[13]),\n                                itemName: elemData.name,\n                                //position: new Vec3(elemData.decomposedMatrix.position),\n                                //scale: new Vec3(elemData.decomposedMatrix.scaling),\n                                //rotation: new Vec3(elemData.decomposedMatrix.rotation),\n                            }\n\n                            const spriteInstance = frame.createSpriteInstance({\n                                ...drawableProps,\n                                ...instanceProps,\n                            })\n\n                            if(spriteNames.indexOf(spriteInstance.itemName)==-1) spriteNames.push(spriteInstance.itemName)\n                        }\n                    }\n                }\n            }\n        };\n\n        // Sprites\n        let pendingAtlasIndex = 1;\n        for(const spriteName of spriteNames){\n            if(this.atlasesBySpriteName[spriteName]==null){\n                const spriteJsonPath = this.path + `/spritemap${pendingAtlasIndex}.json`;\n                const altasFetch = await fetch(spriteJsonPath);\n                const dataRaw:SpriteMapJson = await altasFetch.json();\n                const data = normaliseJson(dataRaw) as SpriteMapJson;\n\n                const image = new Image(data.meta.size.w, data.meta.size.h);\n                image.src = this.path + `/spritemap${pendingAtlasIndex}.png`;\n\n                \n                const atlas = this.createAtlas({\n                    image,\n                    app: data.meta.app,\n                    version: data.meta.version,\n                    imagePath: data.meta.image,\n                    format: data.meta.format,\n                    size: data.meta.size,\n                    resolution: data.meta.resolution \n                })\n                for(const spriteSpriteData of data.atlas.sprites){\n                    const spriteData = spriteSpriteData.sprite;\n                    const sprite = this.createSprite(atlas, {\n                        name: spriteData.name,\n                        x: spriteData.x,\n                        y: spriteData.y,\n                        width: spriteData.w,\n                        height: spriteData.h,\n                        rotated: spriteData.rotated,\n                    })\n                    this.atlasesBySpriteName[sprite.name] = atlas;\n                }\n\n\n                pendingAtlasIndex++;\n            }\n        }\n\n    }\n\n\n}\n", "import { Drawable } from \"./Drawable\";\nimport { Library } from \"./Library\";\n\n\nexport abstract class AnimationContext{\n\n    draw: (item:Drawable, frame:Float, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void, lerp?:boolean) => void\n\n    constructor(){\n        this.draw = null! // OVERRIDE THIS IN THE BASE CLASS!\n    }\n\n  \n    createLibrary(name:string, path:string){\n        const library = new Library(name, path, this);\n        return library;\n    }\n\n\n}", "import { AnimationContext } from \"./core/AnimationContext\"\nimport { ClipInstance } from \"./core/ClipInstance\";\nimport { Drawable } from \"./core/Drawable\"\nimport { Frame } from \"./core/Frame\";\nimport { Instance } from \"./core/Instance\"\nimport { Sprite } from \"./core/Sprite\"\nimport { SpriteInstance } from \"./core/SpriteInstance\";\nimport { modWrap } from \"./core/util\";\n\n\n// This is all of the library's rendering code required to draw into a canvas 2d context.\n// This could easily be ported to any immediate mode rendering context, ie WebGL.\n// This could also be ported to scene graph based libraries like PixiJS, or event the DOM,\n// with a few modification to faciliate mapping to a scene graph.\nexport class Canvas2dAnimationContext extends AnimationContext{\n    \n    ctx:CanvasRenderingContext2D;\n    \n\n    constructor(ctx:CanvasRenderingContext2D){\n        super();\n        this.ctx = ctx;\n    }\n\n\n    draw = (item:Drawable, frame:Float, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void, lerp?:boolean) => {\n        if(item instanceof SpriteInstance){\n            this.ctx.save()\n            this.transformInstance(item, frame, lerp)\n            if(callback) callback(item, frame, lerp)\n            else item.draw(frame, callback, lerp)\n            this.ctx.restore()\n        }else if(item instanceof ClipInstance){\n            this.ctx.save()\n            this.transformInstance(item, frame, lerp)\n            if(callback) callback(item, frame, lerp)\n            else item.draw(frame, callback, lerp)\n            this.ctx.restore()\n        }else if(item instanceof Sprite){\n            if(callback) callback(item, frame, lerp)\n            this.ctx.drawImage(item.atlas.image, item.x, item.y, item.width, item.height, 0, 0, item.width, item.height)\n        }else{\n            if(callback) callback(item, frame, lerp)\n            else item.draw(frame, callback, lerp)\n        }\n    }\n\n\n    transformInstance(item:Instance, frame:Float, lerp?:boolean){\n        if(lerp && item.next){\n            const t = (modWrap(frame, item.totalFrames)-item.index) / item.frame.totalFrames;\n            const m1 = item.matrix2d\n            const m2 = item.next.matrix2d \n            this.ctx.transform(\n                m1.a + (m2.a-m1.a)*t,\n                m1.b + (m2.b-m1.b)*t,\n                m1.c + (m2.c-m1.c)*t,\n                m1.d + (m2.d-m1.d)*t,\n                m1.e + (m2.e-m1.e)*t,\n                m1.f + (m2.f-m1.f)*t,\n            )\n        }else{\n            this.ctx.transform(item.matrix2d.a, item.matrix2d.b, item.matrix2d.c, item.matrix2d.d, item.matrix2d.e, item.matrix2d.f)\n        }\n    }\n    \n}", "import { setupCanvas } from \"./example-utils\";\nimport { Canvas2dAnimationContext } from \"../Canvas2dAnimationContext\";\nimport { Drawable } from \"../core/Drawable\";\nimport { Clip } from \"../core/Clip\";\nimport { Layer } from \"../core/Layer\";\nimport { Frame } from \"../core/Frame\";\nimport { Instance } from \"../core/Instance\";\nimport { Sprite } from \"../core/Sprite\";\nimport { modWrap } from \"../core/util\";\n\n// Set up canvas\nconst canvas = document.getElementById(\"canvas\") as HTMLCanvasElement\nconst ctx = canvas.getContext('2d')!\nvar dpr = setupCanvas(canvas) // Device pixel ratio\n\n// Set up animation context and animation libraries\nconst animContext = new Canvas2dAnimationContext(ctx)\nconst hatsLibrary = animContext.createLibrary('hats', './hats')\n\n\nasync function init(){\n    await hatsLibrary.loadData();\n    update();\n}\n\n\nlet frame = 0;\nlet hatIndex = 3;\nlet showSpriteBorders = false;\nlet eyesFrame = 1;\nlet noseRotation = 0;\nlet reverse = false;\nlet playSpeed = 1;\nlet lerp = false;\n\ndocument.onkeydown = e => {\n    switch(e.key){\n        case '1': hatIndex = 0; break;\n        case '2': hatIndex = 1; break;\n        case '3': hatIndex = 2; break;\n        case '4': hatIndex = 3; break;\n        case 'r': reverse = !reverse; break;\n        case '=': playSpeed *= 2; break;\n        case '-': playSpeed /= 2; break;\n        case 'l': lerp = !lerp; break;\n        case 'ArrowUp': eyesFrame++; break\n        case 'ArrowDown': eyesFrame--; break\n        case 'ArrowLeft': noseRotation+=0.2; break\n        case 'ArrowRight': noseRotation-=0.2; break\n        case ' ': showSpriteBorders = !showSpriteBorders; break\n    }\n\n    hatIndex = modWrap(hatIndex, 4)\n    eyesFrame = modWrap(eyesFrame, 2)\n}\n\n\n// Note: This is a recursive function. It will walk\n// the logic along the display hierarchy. The hierarchy\n// is like this:\n//\n// - Clip\n//     - Layer\n//     - Layer\n//          - Frame (since frame chosen by frame:number)\n//              - Instance\n//              - Instance\n//                  - Sprite or Clip \n//\n// This function shows a few different ways you can dynamically manipulate\n// the rendering:\n//     - How you can dynamically set a frame on a layer (which you could also do on a clip)\n//     - How you can dynamically swap out one clip for another\n//     - How you can draw arbitrary stuff on the 2d context\n//     - How you can apply state base transformations\n//\nfunction drawWithLogic(item:Drawable, frame:number, lerp?:boolean){\n    if(item instanceof Clip){\n        // Rotate any clip named game/Walker_Nose_Nose\n        if(item.name == \"game/Walker_Nose_Nose\"){\n            ctx.save();\n                ctx.rotate(noseRotation)\n                item.draw(frame, drawWithLogic, lerp)\n            ctx.restore();\n        }else{\n            item.draw(frame, drawWithLogic, lerp)\n        }\n    }else if(item instanceof Layer){\n        // If the layer name is \"layer_eye\", choose the frame\n        if(item.name==\"layer_eye\"){\n            item.draw(eyesFrame, drawWithLogic, lerp)\n        }else{\n            item.draw(frame, drawWithLogic, lerp)\n        }\n    }else if(item instanceof Frame){\n        item.draw(frame, drawWithLogic, lerp)\n    }else if(item instanceof Instance){\n        // If the instance's layer name is \"layer_hat\", choose the hat clip\n        if(item.frame.layer.name==\"layer_hat\"){\n            hatsLibrary.symbol(\"Hat_\"+hatIndex).draw(frame, drawWithLogic, lerp)\n        }else{\n            item.draw(frame, drawWithLogic, lerp)\n        }\n    }else if(item instanceof Sprite){\n        item.draw(frame) // Note: leaf node, so don't supply drawWithLogic as an argument\n        // Draw a red border over any sprite\n        if(showSpriteBorders){\n            ctx.strokeStyle = '#CC0000'\n            ctx.strokeRect(0, 0, item.width, item.height)\n        }\n    }\n}\n\n\nfunction update(){\n    ctx.fillStyle = '#cccccc'\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    \n    ctx.save();\n\n        ctx.fillStyle = '#333333'\n        ctx.font = '36px sans-serif';\n        ctx.fillText('1,2,3,4: Change hat', 20, 50);\n        ctx.fillText('Up/Down: Change eyes', 20, 100);\n        ctx.fillText('Left/Right: Rotate nose', 20, 150);\n        ctx.fillText('Spacebar: Toggle debug border', 20, 200);\n        ctx.fillText('l: Toggle lerp', 20, 250);\n        ctx.fillText('r: Reverse play speed', 20, 300);\n        ctx.fillText('+ and -: Change play speed', 20, 350);\n        \n        ctx.translate(canvas.width/2, canvas.height/2)\n        ctx.scale(dpr, dpr)\n\n        ctx.save();\n            ctx.translate(-200, 0)\n            hatsLibrary.symbol(\"Walker_Laser\").draw(frame, drawWithLogic, lerp)\n        ctx.restore()\n\n        ctx.save()\n            ctx.translate(0, 0)\n            hatsLibrary.symbol(\"Walker_Nose\").draw(frame, drawWithLogic, lerp)\n        ctx.restore()\n\n        ctx.save();\n            ctx.translate(200, -50)\n            hatsLibrary.symbol(\"StarDude\").draw(frame, drawWithLogic, lerp)\n        ctx.restore()\n    \n    ctx.restore()\n    \n    frame += reverse ? -playSpeed : playSpeed;\n    requestAnimationFrame(update)\n}\n\n\ninit();\n\n"],
  "mappings": "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",
  "names": []
}
