{
  "version": 3,
  "sources": ["../src/examples/example-utils.ts", "../src/core/Drawable.ts", "../src/core/Instance.ts", "../src/core/ClipInstance.ts", "../src/core/SpriteInstance.ts", "../src/core/Frame.ts", "../src/core/util.ts", "../src/core/Layer.ts", "../src/core/Clip.ts", "../src/core/geom/Vec3.ts", "../src/core/geom/Vec2.ts", "../src/core/geom/Matrix2d.ts", "../src/core/Sprite.ts", "../src/core/Atlas.ts", "../src/core/json/utilJson.ts", "../src/core/Library.ts", "../src/core/AnimationContext.ts", "../src/Canvas2dAnimationContext.ts", "../src/examples/dynamic-content.ts"],
  "sourcesContent": ["import { Clip } from \"../core/Clip\";\nimport { Library } from \"../core/Library\";\n\n\nexport function setupCanvas(canvas:HTMLCanvasElement) {\n    // Set the context quality and smoothing\n    const ctx = canvas.getContext('2d')!\n    ctx.imageSmoothingEnabled = true;\n    ctx.imageSmoothingQuality = 'high'\n\n    // Set the canvas according to window width\n    var bodyRec = document.body.getBoundingClientRect();\n    canvas.width = Math.min(1000, bodyRec.width - 8);\n    canvas.height = canvas.width;\n\n    // Get the device pixel ratio, falling back to 1.\n    let dpr = window.devicePixelRatio || 1;\n\n    // Get the size of the canvas in CSS pixels.\n    let rect = canvas.getBoundingClientRect();\n    \n    // Give the canvas pixel dimensions of their CSS\n    // size * the device pixel ratio.\n    canvas.style.border = \"2px solid gray\";\n    canvas.style.width = \"\" + canvas.width + \"px\";\n    canvas.style.height = \"\" + canvas.height + \"px\";\n    canvas.width = rect.width * dpr;\n    canvas.height = rect.height * dpr;\n\n    return dpr;\n}\n\n\n\nexport function addExampleButtons(libraryKey:string, libs:Record<string, Library>, onLibrarySelected:(nextLibrary:Library)=>void, onSymbolPicked:(nextSymbol:Clip)=>void, onMinus:()=>void, onPlus:()=>void){\n    const library = libs[libraryKey]\n    const buttons = document.getElementById(\"buttons\")!\n\n    const selector = document.createElement('select')\n    selector.value = libraryKey\n    selector.onchange = (e) => {\n        const buttons = document.getElementById('buttons')!\n        while(buttons.childNodes.length > 0) buttons.childNodes[0].remove();\n        addExampleButtons(selector.value, libs, onLibrarySelected, onSymbolPicked, onMinus, onPlus)\n        onLibrarySelected(libs[selector.value])\n    }\n    buttons.appendChild(selector)\n    for(const libraryName of Object.keys(libs)){\n        const option = document.createElement('option')\n        option.value = libraryName\n        option.selected = libraryName == libraryKey\n        option.innerText = libraryName\n        selector.appendChild(option)\n    }\n\n    const minusButton = document.createElement('button')\n    minusButton.innerHTML = '-'\n    minusButton.onclick = onMinus\n    buttons.appendChild(minusButton);\n\n    const plusButton = document.createElement('button')\n    plusButton.innerHTML = '+'\n    plusButton.onclick = onPlus\n    buttons.appendChild(plusButton);\n\n    for(const clip of library.clips){\n        if(clip.name.indexOf(\"/\")!=-1 || clip.name.indexOf(\"Symbol \")==0 || clip.name.indexOf(\"Tween \")==0 || clip.name.indexOf(\"/Symbol \")!=-1 || clip.name.indexOf(\"/Tween \")!=-1) continue;\n        var button = document.createElement(\"button\")\n        button.innerHTML = clip.name\n        button.onclick = () => onSymbolPicked(clip)\n        buttons.appendChild(button)\n    }\n}", "import { Library } from \"./Library\";\n\ntype Int = number;\ntype Float = number;\n\n\nexport type DrawableProps = {\n    name:string,\n    id:string,\n    totalFrames:Int,\n    library:Library;\n}\n\n\nexport abstract class Drawable{\n    name:string;\n    id:string;\n    totalFrames:Int = 1;\n    library:Library;\n\n\n    constructor(props:DrawableProps){\n        this.name = props.name;\n        this.id = props.id;\n        this.totalFrames = props.totalFrames;\n        this.library = props.library;\n    }\n\n\n    public visit(frame:Float, callback:(item:Drawable, frame:Float, ...args:any)=>void):void{\n        // Override in base class\n    }\n\n\n    public draw(frame:Float, callback?:(item:Drawable, frame:Float)=>void){\n        // Override in base class\n    }\n\n}", "import { Drawable } from \"./Drawable\";\nimport { Frame } from \"./Frame\";\nimport { Matrix2d } from \"./geom/Matrix2d\";\nimport { Vec3 } from \"./geom/Vec3\";\nimport { DrawableProps } from './Drawable'\n\n\nexport type InstanceProps = Omit<DrawableProps, 'id' | 'library'> & {\n    itemName:string,\n    matrix2d:Matrix2d,\n    position:Vec3,\n    scale:Vec3,\n    rotation:Vec3,\n    frame:Frame,\n}\n\n\nexport class Instance extends Drawable{\n\n    matrix2d:Matrix2d;\n    position:Vec3;\n    scale:Vec3;\n    rotation:Vec3;\n    frame:Frame;\n    //filters = new Array<Filter>();\n    index:number;\n    itemName:string;\n\n    \n    constructor(props:InstanceProps){\n        super({\n            ...props,\n            library: props.frame.library,\n            id: `${props.frame.id}.${props.frame.instances.length}`,\n        });\n\n        this.itemName = props.itemName;\n        this.matrix2d = props.matrix2d;\n        this.position = props.position;\n        this.scale = props.scale;\n        this.rotation = props.rotation;\n        this.frame = props.frame;\n        this.index = this.frame.instances.length;\n    }\n\n\n    public get item():Drawable{\n        throw(\"Override item getter in base class\");\n    }\n\n\n    public draw(frame:Float, callback?:(item:Drawable, frame:Float, ...args:any)=>void):void{\n        this.library.context.draw(this.item, frame, callback)\n    }\n\n\n    public visit(frame:Float, callback:(item:Drawable, frame:Float, ...args:any)=>void):void{\n        callback(this, frame)\n    }\n\n\n    /*\n    public visit(frame:Float, callback:(item:Drawable, frame:Float, ...args:any)=>void):void{\n        callback(this.item, frame);\n    }\n    */\n\n}", "import { Vec2 } from \"./geom/Vec2\";\nimport { Instance } from \"./Instance\";\nimport { InstanceProps } from \"./Instance\"\n\ntype LoopKind = 'loop' // TODO: HANDLE OTHER LOOP KINDS | 'PlayOnce' | 'SingleFrame' | 'PlayOnceReverse' | 'LoopReverse'\n\n\ntype ClipInstanceBehavior = {\n    type: 'graphic'\n    loop:LoopKind;\n    firstFrame:Float;\n} | {\n    type: 'movieclip'\n}\n\n\nexport type ClipInstanceProps = InstanceProps & { \n    transformationPoint:Vec2,   \n    behaviour:ClipInstanceBehavior\n}\n\n\nexport class ClipInstance extends Instance{\n\n    transformationPoint:Vec2\n    behaviour:ClipInstanceBehavior\n    //color:Null<Color>;\n    \n    \n    constructor(props:ClipInstanceProps){\n        super(props);\n        this.behaviour = props.behaviour;\n        this.transformationPoint = props.transformationPoint;\n    }\n\n\n    public get item(){\n        return this.library.clipsByName[this.itemName];\n    }\n\n}\n", "import { Instance, InstanceProps } from \"./Instance\";\n\ntype Float = number;\n\nexport type SpriteInstanceProps = InstanceProps & {\n\n}\n\n\nexport class SpriteInstance extends Instance{\n\n    constructor(props:SpriteInstanceProps){\n        super(props)\n    }\n\n    \n    public get item(){\n        return this.library.spritesByName[this.itemName];\n    }\n\n\n}\n", "import { ClipInstance, ClipInstanceProps } from \"./ClipInstance\";\nimport { Drawable } from \"./Drawable\";\nimport { Layer } from \"./Layer\";\nimport { SpriteInstance, SpriteInstanceProps } from \"./SpriteInstance\";\nimport { DrawableProps } from \"./Drawable\";\n\n\ntype Int = number;\n\n\nexport type FrameProps = Omit<DrawableProps, 'id' | 'library'> & {\n    index:Int,\n    layer:Layer,\n    labelName:string|undefined,\n}\n\n\nexport class Frame extends Drawable{\n\n    index:number\n    labelName:string|null;\n    layer:Layer;\n    instances:Array<ClipInstance|SpriteInstance> = [];\n\n\n    constructor(props:FrameProps){\n        super({\n            ...props,\n            id: `${props.layer.id}.${props.index}`,\n            library: props.layer.library\n        });\n        \n        this.layer = props.layer;\n        this.index = props.index;\n        this.labelName = props.labelName || null;\n    }\n\n\n    public createClipInstance(props:Omit<ClipInstanceProps, 'frame'>){\n        const clipInstance = new ClipInstance({...props, frame:this})\n        this.instances.push(clipInstance);\n        return clipInstance;\n    }\n\n\n    public createSpriteInstance(props:Omit<SpriteInstanceProps, 'frame'>){\n        const spriteInstance = new SpriteInstance({...props, frame:this})\n        this.instances.push(spriteInstance)\n        return spriteInstance\n    }\n\n\n    public draw(frame:Float, callback?:(item:Drawable, frame:Float, ...args:any)=>void):void{\n        for(const instance of this.instances){\n            this.library.context.draw(instance, frame, callback)\n        }\n    }\n\n\n    public visit(frame:Float, callback:(item:Drawable, frame:Float, ...args:any)=>void):void{\n        callback(this, frame)\n        for(const instance of this.instances){\n            instance.visit(frame, callback)\n        }\n    }\n\n\n    /*\n    public visit(frame:Float, callback:(item:Drawable, frame:Float, ...args:any)=>void):void{\n        for(const instance of this.instances){\n            callback(instance, frame);\n        }\n    }\n    */\n\n}\n", "\nexport function modWrap(a:number, b:number){\n    return a - b * Math.floor(a/b);\n}\n", "import { Clip } from \"./Clip\";\nimport { Drawable } from \"./Drawable\";\nimport { Frame, FrameProps } from \"./Frame\";\nimport { DrawableProps } from \"./Drawable\"\nimport { modWrap } from \"./util\";\n\n\ntype Int = number;\ntype Float = number;\n\n\nexport type LayerProps = Omit<DrawableProps, 'totalFrames'|'id'|'library'> & {\n    clip:Clip\n}\n\n\nexport class Layer extends Drawable{\n\n    public index:Int;\n    public frames:Array<Frame>;\n    public framesByName:Record<string, Frame>;\n    public labels:Array<Frame>;\n    public clip:Clip;\n\n\n    constructor(props:LayerProps){\n        super({\n            ...props,\n            totalFrames:0,\n            id:`${props.clip.id}.${props.name}`,\n            library: props.clip.library,\n        });\n        \n        this.clip = props.clip;\n        this.index = this.clip.layers.length;\n        this.frames = [];\n        this.framesByName = {};\n        this.labels = [];\n    }\n\n\n    public createFrame(props:Omit<FrameProps, 'layer'>){\n        const frame = new Frame({...props, layer:this});\n        this.frames.push(frame)\n        this.framesByName[frame.name] = frame;\n        if(frame.index+frame.totalFrames > this.totalFrames) this.totalFrames = frame.index+frame.totalFrames\n        if(frame.labelName){\n            this.labels.push(frame);\n        }\n        this.clip.addFrame(frame);\n\n        return frame;\n    }\n\n\n    public keyframeAt(frame:Float){\n        // TODO: Binary search would be a good optimisation here\n        frame = modWrap(frame, this.totalFrames);\n        for(const keyframe of this.frames){\n            if(keyframe.index<=frame && keyframe.index+keyframe.totalFrames > frame)\n            return keyframe;\n        }\n        return null;\n    }\n\n\n    public draw(frame:Float, callback?:(item:Drawable, frame:Float, ...args:any)=>void):void{\n        var keyframe = this.keyframeAt(frame)\n        if(keyframe!=null){\n            this.library.context.draw(keyframe, frame, callback);\n        }\n    }\n\n\n    public visit(frame:Float, callback:(item:Drawable, frame:Float, ...args:any)=>void):void{\n        callback(this, frame);\n        var keyframe = this.keyframeAt(frame)\n        if(keyframe!=null){\n            keyframe.visit(frame, callback)\n        }\n    }\n\n\n    /*\n    public visit(frame:Float, callback:(item:Drawable, frame:Float, ...args:any)=>void):void{\n        var keyframe = this.keyframeAt(frame)\n        if(keyframe!=null) callback(keyframe, frame);\n    }\n    */\n\n}\n", "import { Drawable } from \"./Drawable\";\nimport { Frame } from \"./Frame\";\nimport { Layer, LayerProps } from \"./Layer\";\nimport { DrawableProps } from './Drawable'\nimport { modWrap } from \"./util\";\n\ntype Float = number;\nexport type ClipProps = Omit<DrawableProps, 'totalFrames'|'id'>\n\n\nexport class Clip extends Drawable{\n\n    layers:Array<Layer>;\n    layersById:Record<string, Layer>;\n    layersByName:Record<string, Layer>;\n    framesById:Record<string, Frame>;\n\n\n    constructor(props:ClipProps){\n        super({\n            ...props,\n            totalFrames:0,\n            id:`${props.library.name}.clips.${props.name}`,\n        })\n        \n        this.layers = [];\n        this.layersById = {};\n        this.layersByName = {};\n        this.framesById = {};\n    }\n\n\n    public createLayer(props:Omit<LayerProps, 'clip'>){\n        const layer = new Layer({...props, clip:this});\n        this.layers.push(layer);\n        this.layersById[layer.id] = layer;\n        this.layersByName[layer.name] = layer;\n        if(layer.totalFrames > this.totalFrames) this.totalFrames = layer.totalFrames;\n\n        return layer;\n    }\n\n\n    public addFrame(frame:Frame){\n        this.framesById[frame.id] = frame;\n        if(frame.layer.totalFrames > this.totalFrames) this.totalFrames = frame.layer.totalFrames;\n    }\n\n\n    public draw(frame:Float, callback?:(item:Drawable, frame:Float)=>void){\n        for(const layer of this.layers){\n            if(layer.totalFrames==0) continue;\n            var f = modWrap(frame, layer.totalFrames);\n            if(layer.totalFrames>=f){\n                this.library.context.draw(layer, frame, callback);\n            }\n        }\n\n    }\n\n\n\n    public visit(frame:Float, callback:(item:Drawable, frame:Float, ...args:any)=>void):void{\n        callback(this, frame)\n        for(const layer of this.layers){\n            if(layer.totalFrames==0) continue;\n            var f = modWrap(frame, layer.totalFrames);\n            if(layer.totalFrames>=f) layer.visit(frame, callback)\n        }\n    }\n\n\n   \n}", "export class Vec3{\n\n    x:Float\n    y:Float\n    z:Float\n    data:Float32Array\n\n    \n    constructor(props:{x:Float, y:Float, z:Float}){\n        this.x = props.x\n        this.y = props.y\n        this.z = props.z\n        this.data = new Float32Array([this.x, this.y, this.z])\n    }\n\n}", "type Float = number;\n\n\nexport class Vec2 {\n\n    x:Float\n    y:Float\n    data:Float32Array\n\n    \n    constructor(props:{x:Float, y:Float}){\n        this.x = props.x\n        this.y = props.y\n        this.data = new Float32Array([this.x, this.y])\n    }\n    \n}", "\nexport class Matrix2d{\n\n    a:number\n    b:number\n    c:number\n    d:number\n    e:number\n    f:number\n    data:Float32Array\n\n\n    constructor(a:number, b:number, c:number, d:number, e:number, f:number){\n        this.a = a\n        this.b = b\n        this.c = c\n        this.d = d\n        this.e = e\n        this.f = f\n        \n        this.data = new Float32Array([this.a, this.b, this.c, this.d, this.e, this.f])\n    }\n\n}", "import { Drawable } from \"./Drawable\";\nimport { Atlas } from \"./Atlas\";\nimport { DrawableProps } from \"./Drawable\"\n\ntype Int = number;\ntype Float = number;\n\n\nexport type SpriteProps = Omit<DrawableProps, 'totalFrames'|'library'|'id'> & {\n    x:Float,\n    y:Float,\n    width:Float,\n    height:Float,\n    rotated:boolean,\n    atlas:Atlas,\n}\n\n\nexport class Sprite extends Drawable{\n    x:Float;\n    y:Float;\n    width:Float;\n    height:Float;\n    rotated:boolean;\n    atlas:Atlas;\n\n    constructor(props:SpriteProps){\n        super({\n            ...props,\n            totalFrames:1,\n            library:props.atlas.library,\n            id:`${props.atlas.library.name}.sprites.${props.name}`\n        })\n        this.x = props.x;\n        this.y = props.y;\n        this.width = props.width;\n        this.height = props.height;\n        this.rotated = props.rotated;\n        this.atlas = props.atlas;\n    }\n\n\n    public draw(frame:Float, callback?:(item:Drawable, frame:Float)=>void){\n        // Override in base class\n    }\n\n\n    public visit(frame:Float, callback:(item:Drawable, frame:Float, ...args:any)=>void):void{\n        callback(this, frame)\n    }\n   \n}\n", "import { Library } from \"./Library\";\nimport { Sprite } from \"./Sprite\";\n\n\nexport type AtlasProps = {\n    library:Library,\n    image:HTMLImageElement,\n    app:string,\n    version:string,\n    imagePath:string,\n    format:string,\n    size:{w:Float, h:Float},\n    resolution:string\n}\n\n\nexport class Atlas{\n    library:Library;\n    sprites:Array<Sprite>;\n    image:HTMLImageElement;\n\n    app:string;\n    version:string;\n    imagePath:string;\n    format:string;\n    size:{w:Float, h:Float};\n    resolution:string;\n\n    \n    constructor(props:AtlasProps){\n        this.sprites = [];\n        this.library = props.library;\n        this.image = props.image;\n        this.app = props.app;\n        this.version = props.version;\n        this.imagePath = props.imagePath;\n        this.format = props.format;\n        this.size = props.size;\n        this.resolution = props.resolution;\n    }\n\n    \n\n}\n", "import { AnimationJson } from \"./AnimationJson\";\n\nconst keys:Record<string, string> = {\n    // fix inconsistent names\n    ANIMATION: \"animation\",\n    ATLAS_SPRITE_instance: \"atlasSpriteInstance\",\n    DecomposedMatrix: \"decomposedMatrix\",\n    Frames: \"frames\",\n    framerate: \"frameRate\",\n    Instance_Name: \"instanceName\",\n    Layer_name: \"layerName\",\n    LAYERS: \"layers\",\n    Matrix3D: \"matrix3D\",\n    Position: \"position\",\n    Rotation: \"rotation\",\n    Scaling: \"scaling\",\n    SYMBOL_DICTIONARY: \"symbolDictionary\",\n    SYMBOL_Instance: \"symbolInstance\",\n    SYMBOL_name: \"symbolName\",\n    Symbols: \"symbols\",\n    TIMELINE: \"timeline\",\n\n    SPRITE: \"sprite\",\n    SPRITES: \"sprites\",\n    ATLAS: \"atlas\",\n\n    /* Not yet supported\n    // fix shortened names\n\n    AN: \"animation\",\n    AM: \"alphaMultiplier\",\n    ASI: \"atlasSpriteInstance\",\n    BM: \"bitmap\",\n    C: \"color\",\n    DU: \"duration\",\n    E: \"elements\",\n    FF: \"firstFrame\",\n    FR: \"frames\",\n    FRT: \"frameRate\",\n    I: \"index\",\n    IN: \"instanceName\",\n    L: \"layers\",\n    LN: \"layerName\",\n    LP: \"loop\",\n    M3D: \"matrix3D\",\n    MD: \"metadata\",\n    M: \"mode\",\n    N: \"name\",\n    POS: \"position\",\n    S: \"symbols\",\n    SD: \"symbolDictionary\",\n    SI: \"symbolInstance\",\n    SN: \"symbolName\",\n    ST: \"symbolType\",\n    TL: \"timeline\",\n    TRP: \"transformationPoint\"\n    */\n};\n\n\nfunction normaliseKey(key:string){\n    return keys[key] || key;\n}\n\n\n\n// AnimateCC exports wildy inconsistent JSON. Normalise the\n// fields to make it easier to work with\nexport function normaliseJson(data:any):any{\n    if(typeof data == \"string\" || typeof data == \"number\") return data\n    switch(typeof data){\n        case \"string\": return data;\n        case \"number\": return data;\n        case \"boolean\": return data;\n        case \"object\":\n            if(Array.isArray(data)){\n                return (data as Array<any>).map(normaliseJson);\n            }else{\n                var result:any = {};\n                Object.keys(data).forEach(key => result[normaliseKey(key)] = normaliseJson(data[key]));\n                return result;\n            }\n        case \"bigint\": throw(\"Not supported\");\n        case \"function\": throw(\"Not supported\");\n        case \"symbol\": throw(\"Not supported\");\n        case \"undefined\": throw(\"Not supported\");\n        default: throw(\"Unsupported\")\n    }\n}\n", "import { AnimationJson } from \"./json/AnimationJson\";\nimport { Clip, ClipProps } from \"./Clip\";\nimport { ClipInstanceProps } from \"./ClipInstance\";\nimport { SpriteInstanceProps } from \"./SpriteInstance\";\nimport { Vec3 } from \"./geom/Vec3\";\nimport { Vec2 } from \"./geom/Vec2\";\nimport { Matrix2d } from \"./geom/Matrix2d\";\nimport { InstanceProps } from \"./Instance\";\nimport { DrawableProps } from \"./Drawable\";\nimport { Sprite, SpriteProps } from \"./Sprite\";\nimport { Atlas, AtlasProps } from \"./Atlas\";\nimport { normaliseJson } from \"./json/utilJson\";\nimport { AnimationContext } from \"./AnimationContext\";\n\n\nexport class Library{\n\n    name:string;\n    path:string;\n    clips:Array<Clip> = [];\n    clipsByName:Record<string, Clip> = {};\n    spritesByName:Record<string, Sprite> = {};\n    atlases:Array<Atlas> = [];\n    atlasesBySpriteName:Record<string, Atlas> = {}\n    context:AnimationContext;\n    \n    \n    constructor(name:string, path:string, context:AnimationContext){\n        this.name = name;\n        this.path = path;\n        this.atlases = [];\n        this.context = context;\n    }\n\n\n    symbol(name:string){\n        if(this.clipsByName[name]) return this.clipsByName[name]\n        if(this.spritesByName[name]) return this.spritesByName[name]\n        throw(\"Cannot find symbol: \" + name + \" for library: \" + this.path);\n    }\n\n\n    createAtlas(props:Omit<AtlasProps, 'library'>){\n        const atlas = new Atlas({...props, library:this});\n        this.atlases.push(atlas);\n        return atlas;\n    }\n\n\n    createSprite(atlas:Atlas, props:Omit<SpriteProps, 'atlas'>){\n        const sprite = new Sprite({...props, atlas:atlas})\n        atlas.sprites.push(sprite);\n        this.spritesByName[sprite.name] = sprite;\n        this.atlasesBySpriteName[sprite.name] = atlas;\n        return sprite;\n    }\n\n\n    createClip(props:Omit<ClipProps, 'library'>){\n        const clip = new Clip({...props, library:this});\n        this.clips.push(clip)\n        this.clipsByName[clip.name] = clip\n        return clip;\n    }\n\n\n    public async loadData(){\n        const animJsonPath = this.path + \"/Animation.json\";\n        const animFetchResult = await fetch(animJsonPath);\n        const dataRaw:AnimationJson = await animFetchResult.json();\n        const data = normaliseJson(dataRaw) as AnimationJson;\n        const spriteNames:Array<string> = [];\n\n        // Clip\n        for(const symbolData of data.symbolDictionary.symbols){\n            const clip = this.createClip({\n                name: symbolData.symbolName,\n            })\n\n            // Layer\n            for(let l=symbolData.timeline.layers.length-1; l>=0; l--){\n                const layerData = symbolData.timeline.layers[l]\n                const layer = clip.createLayer({\n                    name: layerData.layerName,\n                })\n\n                // Frame\n                for(const frameData of layerData.frames){\n                    const frame = layer.createFrame({\n                        name: \"\"+frameData.index,\n                        totalFrames: frameData.duration,\n                        labelName: frameData.name,\n                        index: frameData.index,\n                    })\n\n                    // Element\n                    for(const elemInstanceData of  frameData.elements){\n                        if(\"symbolInstance\" in elemInstanceData){\n                            type _DrawableProps = Pick<DrawableProps, keyof DrawableProps & keyof ClipInstanceProps>;\n                            type _InstanceProps = Omit<InstanceProps, keyof DrawableProps>\n                            \n                            const elemData = elemInstanceData.symbolInstance;\n                            const m = elemData.matrix3D;\n\n                            const drawableProps:_DrawableProps = {\n                                name: frame.name,\n                                totalFrames: frame.totalFrames,\n                            }\n\n                            const instanceProps:_InstanceProps  = {\n                                frame,\n                                matrix2d: new Matrix2d(m.m00, m.m01, m.m10, m.m11, m.m30, m.m31),\n                                position: new Vec3(elemData.decomposedMatrix.position),\n                                scale: new Vec3(elemData.decomposedMatrix.scaling),\n                                rotation: new Vec3(elemData.decomposedMatrix.rotation),\n                                itemName: elemData.symbolName,\n                            }\n\n                            const clipInstance = frame.createClipInstance({\n                                ...drawableProps,\n                                ...instanceProps,\n                                transformationPoint: new Vec2(elemData.transformationPoint),\n                                behaviour: elemData.symbolType == \"graphic\"\n                                         ? { type: 'graphic', loop: elemData.loop, firstFrame: elemData.firstFrame}\n                                         : { type: 'movieclip' }\n                            })\n                        }else{\n                            type _DrawableProps = Pick<DrawableProps, keyof DrawableProps & keyof SpriteInstanceProps>;\n                            type _InstanceProps = Omit<InstanceProps, keyof DrawableProps>\n                            \n                            const elemData = elemInstanceData.atlasSpriteInstance;\n                            const m = elemData.matrix3D;\n\n                            const drawableProps:_DrawableProps = {\n                                name: frame.name,\n                                totalFrames: frame.totalFrames,\n                            }\n\n                            const instanceProps:_InstanceProps  = {\n                                frame,\n                                matrix2d: new Matrix2d(m.m00, m.m01, m.m10, m.m11, m.m30, m.m31),\n                                position: new Vec3(elemData.decomposedMatrix.position),\n                                scale: new Vec3(elemData.decomposedMatrix.scaling),\n                                rotation: new Vec3(elemData.decomposedMatrix.rotation),\n                                itemName: elemData.name,\n                            }\n\n                            const spriteInstance = frame.createSpriteInstance({\n                                ...drawableProps,\n                                ...instanceProps,\n                            })\n\n                            if(spriteNames.indexOf(spriteInstance.itemName)==-1) spriteNames.push(spriteInstance.itemName)\n                        }\n                    }\n                }\n            }\n        };\n\n        // Sprites\n        let pendingAtlasIndex = 1;\n        for(const spriteName of spriteNames){\n            if(this.atlasesBySpriteName[spriteName]==null){\n                const spriteJsonPath = this.path + `/spritemap${pendingAtlasIndex}.json`;\n                const altasFetch = await fetch(spriteJsonPath);\n                const dataRaw:SpriteMapJson = await altasFetch.json();\n                const data = normaliseJson(dataRaw) as SpriteMapJson;\n\n                const image = new Image(data.meta.size.w, data.meta.size.h);\n                image.src = this.path + `/spritemap${pendingAtlasIndex}.png`;\n\n                \n                const atlas = this.createAtlas({\n                    image,\n                    app: data.meta.app,\n                    version: data.meta.version,\n                    imagePath: data.meta.image,\n                    format: data.meta.format,\n                    size: data.meta.size,\n                    resolution: data.meta.resolution \n                })\n                for(const spriteSpriteData of data.atlas.sprites){\n                    const spriteData = spriteSpriteData.sprite;\n                    const sprite = this.createSprite(atlas, {\n                        name: spriteData.name,\n                        x: spriteData.x,\n                        y: spriteData.y,\n                        width: spriteData.w,\n                        height: spriteData.h,\n                        rotated: spriteData.rotated,\n                    })\n                    this.atlasesBySpriteName[sprite.name] = atlas;\n                }\n\n\n                pendingAtlasIndex++;\n            }\n        }\n\n    }\n\n\n}\n", "import { Drawable } from \"./Drawable\";\nimport { Library } from \"./Library\";\n\n\nexport abstract class AnimationContext{\n\n    draw: (item:Drawable, frame:Float, callback?:(item:Drawable, frame:Float)=>void) => void\n\n    constructor(){\n        this.draw = null! // OVERRIDE THIS IN THE BASE CLASS!\n    }\n\n  \n    createLibrary(name:string, path:string){\n        const library = new Library(name, path, this);\n        return library;\n    }\n\n\n}", "import { AnimationContext } from \"./core/AnimationContext\"\nimport { Drawable } from \"./core/Drawable\"\nimport { Frame } from \"./core/Frame\";\nimport { Instance } from \"./core/Instance\"\nimport { Sprite } from \"./core/Sprite\"\nimport { SpriteInstance } from \"./core/SpriteInstance\";\n\n\nexport class Canvas2dAnimationContext extends AnimationContext{\n    \n    ctx:CanvasRenderingContext2D;\n    \n\n    constructor(ctx:CanvasRenderingContext2D){\n        super();\n        this.ctx = ctx;\n    }\n\n\n    draw = (item:Drawable, frame:Float, callback?:(item:Drawable, frame:Float)=>void) => {\n        if(item instanceof Instance){\n            this.ctx.save()\n            this.ctx.transform(item.matrix2d.a, item.matrix2d.b, item.matrix2d.c, item.matrix2d.d, item.matrix2d.e, item.matrix2d.f)\n            if(callback) callback(item, frame)\n            else item.draw(frame, callback)\n            this.ctx.restore()\n        }else if(item instanceof Sprite){\n            if(callback) callback(item, frame)\n            this.ctx.drawImage(item.atlas.image, item.x, item.y, item.width, item.height, 0, 0, item.width, item.height)\n        }else{\n            if(callback) callback(item, frame)\n            else item.draw(frame, callback)\n        }\n    }\n\n}", "import { setupCanvas } from \"./example-utils\";\nimport { Canvas2dAnimationContext } from \"../Canvas2dAnimationContext\";\nimport { Drawable } from \"../core/Drawable\";\nimport { Clip } from \"../core/Clip\";\nimport { Layer } from \"../core/Layer\";\nimport { Frame } from \"../core/Frame\";\nimport { Instance } from \"../core/Instance\";\nimport { Sprite } from \"../core/Sprite\";\nimport { modWrap } from \"../core/util\";\n\n// Set up canvas\nconst canvas = document.getElementById(\"canvas\") as HTMLCanvasElement\nconst ctx = canvas.getContext('2d')!\nvar dpr = setupCanvas(canvas) // Device pixel ratio\n\n// Set up animation context and animation libraries\nconst animContext = new Canvas2dAnimationContext(ctx)\nconst hatsLibrary = animContext.createLibrary('hats', './hats')\n\n\nasync function init(){\n    await hatsLibrary.loadData();\n\n    let frame = 0;\n    let hat = 3;\n    let showSpriteBorders = false;\n    let eyes = 1;\n\n    document.onkeydown = e => {\n        switch(e.key){\n            case 'ArrowUp': hat++; break\n            case 'ArrowDown': hat--; break\n            case 'ArrowLeft': eyes--; break\n            case 'ArrowRight': eyes++; break\n            case ' ': showSpriteBorders = !showSpriteBorders; break\n        }\n\n        hat = modWrap(hat, 4)\n        eyes = modWrap(eyes, 2)\n    }\n    \n    function drawWithLogic(item:Drawable, frame:number){\n        // Clip\n        if(item instanceof Clip){\n            item.draw(frame, drawWithLogic)\n\n        // Layer\n        }else if(item instanceof Layer){\n            if(item.name==\"layer_eye\"){\n                item.draw(eyes, drawWithLogic)\n            }else{\n                item.draw(frame, drawWithLogic)\n            }\n        \n        // Frame\n        }else if(item instanceof Frame){\n            item.draw(frame, drawWithLogic)\n\n        // Hat\n        }else if(item instanceof Instance){\n            if(item.frame.layer.name==\"layer_hat\"){\n                hatsLibrary.symbol(\"Hat_\"+hat).draw(frame, drawWithLogic)\n            }else{\n                item.draw(frame, drawWithLogic)\n            }\n            \n        // Sprite\n        }else if(item instanceof Sprite){\n            item.draw(frame)\n            if(showSpriteBorders){\n                ctx.strokeStyle = '#CC0000'\n                ctx.strokeRect(0, 0, item.width, item.height)\n            }\n        }\n    }\n   \n    \n    function update(){\n        ctx.fillStyle = '#cccccc'\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        ctx.save();\n\n        ctx.fillStyle = '#333333'\n        ctx.font = '36px sans-serif';\n        ctx.fillText('Up/Down: Change hat', 20, 50);\n        ctx.fillText('Left/Right: Change eyes', 20, 100);\n        ctx.fillText('Spacebar: Toggle debug border', 20, 150);\n        \n\n        ctx.translate(canvas.width/2, canvas.height/2)\n        ctx.scale(dpr, dpr)\n\n        ctx.save();\n        ctx.translate(-100, 0)\n        hatsLibrary.symbol(\"Walker_Laser\").draw(frame, drawWithLogic)\n        ctx.restore()\n\n        ctx.save()\n        ctx.translate(100, 0)\n        hatsLibrary.symbol(\"Walker_Nose\").draw(frame, drawWithLogic)\n        ctx.restore()\n        \n        ctx.restore()\n        \n        frame++;\n        requestAnimationFrame(update)\n    }\n    update();\n\n}\n\ninit();\n\n"],
  "mappings": "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",
  "names": []
}
