{
  "version": 3,
  "sources": ["../src/core/Drawable.ts", "../src/core/geom/Vec2.ts", "../src/core/Instance.ts", "../src/core/util/math.ts", "../src/core/ClipInstance.ts", "../src/core/SpriteInstance.ts", "../src/core/Frame.ts", "../src/core/Layer.ts", "../src/core/Clip.ts", "../src/core/Sprite.ts", "../src/core/Atlas.ts", "../src/core/json/utilJson.ts", "../src/core/geom/Matrix.ts", "../src/core/util/createImage.ts", "../src/core/Library.ts", "../src/core/Scene.ts", "../src/index.ts", "../src/DomScene.ts", "../src/examples/dom.ts"],
  "sourcesContent": ["import { Library } from \"./Library\";\n\ntype Int = number;\ntype Float = number;\n\n\nexport type DrawableProps = {\n    name:string,\n    id:string,\n    totalFrames:Int,\n    library:Library;\n}\n\n\nexport abstract class Drawable{\n    name:string;\n    id:string;\n    totalFrames:Int = 1;\n    library:Library;\n\n\n    constructor(props:DrawableProps){\n        this.name = props.name;\n        this.id = props.id;\n        this.totalFrames = props.totalFrames;\n        this.library = props.library;\n    }\n\n\n    public get scene(){\n        return this.library.scene;\n    }\n\n\n    public draw(frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void){\n        // Override in base class\n    }\n\n}", "type Float = number;\n\n\nexport class Vec2 {\n\n    x:Float\n    y:Float\n    data:Float32Array\n\n    \n    constructor(props:{x:Float, y:Float}){\n        this.x = props.x\n        this.y = props.y\n        this.data = new Float32Array([this.x, this.y])\n    }\n    \n}", "import { Drawable } from \"./Drawable\";\nimport { Frame } from \"./Frame\";\nimport { DrawableProps } from './Drawable'\nimport { Matrix } from \"./geom/Matrix\";\nimport { Color, Filters } from \"./json/AnimationJson\";\n\n\nexport type InstanceProps = Omit<DrawableProps, 'id' | 'library'> & {\n    itemName:string,\n    matrix:Matrix,\n    frame:Frame,\n    filters?:Filters|null,\n    color?:Color|null,\n    //position:Vec3,\n    //scale:Vec3,\n    //rotation:Vec3,\n}\n\n\nexport class Instance extends Drawable{\n\n    matrix3d:Matrix;\n    frame:Frame;\n    index:number;\n    itemName:string;\n    filters:Filters|null;\n    color:Color|null;\n    //position:Vec3;\n    //scale:Vec3;\n    //rotation:Vec3;\n    //filters = new Array<Filter>();\n\n    \n    constructor(props:InstanceProps){\n        super({\n            ...props,\n            library: props.frame.library,\n            id: `${props.frame.id}.${props.frame.instances.length}`,\n        });\n\n        this.itemName = props.itemName;\n        this.matrix3d = props.matrix;\n        this.filters = props.filters || null;\n        this.color = props.color || null;\n        //this.position = props.position;\n        //this.scale = props.scale;\n        //this.rotation = props.rotation;\n        this.frame = props.frame;\n        this.index = this.frame.instances.length;\n    }\n\n\n    public get prev():Instance|undefined{\n        const item = this.frame.prev?.instances[this.index]\n        return item?.itemName==this.itemName ? item : undefined \n    }\n\n\n    public get next():Instance|undefined{\n        const item = this.frame.next?.instances[this.index]\n        return item?.itemName==this.itemName ? item : undefined\n    }\n\n\n    public get item():Drawable{\n        throw(\"Override item getter in base class\");\n    }\n\n\n    public draw(frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void):void{\n        this.library.scene.draw(this.item, frame, lerp, callback)\n    }\n\n\n}", "\nexport function modWrap(a:number, b:number){\n    return a - b * Math.floor(a/b);\n}\n", "import { Drawable } from \"./Drawable\";\nimport { Vec2 } from \"./geom/Vec2\";\nimport { Instance } from \"./Instance\";\nimport { InstanceProps } from \"./Instance\"\nimport { modWrap } from \"./util/math\";\n\ntype LoopKind = 'loop' // TODO: HANDLE OTHER LOOP KINDS | 'PlayOnce' | 'SingleFrame' | 'PlayOnceReverse' | 'LoopReverse'\n\n\ntype ClipInstanceBehavior = {\n    type: 'graphic'\n    loop:LoopKind;\n    firstFrame:Float;\n} | {\n    type: 'movieclip'\n}\n\n\nexport type ClipInstanceProps = InstanceProps & { \n    transformationPoint?:Vec2,   \n    behaviour?:ClipInstanceBehavior\n}\n\n\nexport class ClipInstance extends Instance{\n\n    transformationPoint:Vec2\n    behaviour:ClipInstanceBehavior\n    \n    \n    constructor(props:ClipInstanceProps){\n        super(props);\n        this.behaviour = props.behaviour || { type: 'movieclip' };\n        this.transformationPoint = props.transformationPoint || new Vec2({x:0, y:0});\n    }\n\n\n    public get item(){\n        return this.library.clipsByName[this.itemName];\n    }\n\n\n    public draw(frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void):void{\n        if(this.behaviour.type == 'graphic'){\n            frame = this.behaviour.firstFrame + modWrap(frame, 1);\n        }\n        this.library.scene.draw(this.item, frame, lerp, callback)\n    }\n\n\n}\n", "import { Instance, InstanceProps } from \"./Instance\";\n\ntype Float = number;\n\nexport type SpriteInstanceProps = InstanceProps & {\n\n}\n\n\nexport class SpriteInstance extends Instance{\n\n    constructor(props:SpriteInstanceProps){\n        super(props)\n    }\n\n    \n    public get item(){\n        return this.library.spritesByName[this.itemName];\n    }\n\n\n}\n", "import { ClipInstance, ClipInstanceProps } from \"./ClipInstance\";\nimport { Drawable } from \"./Drawable\";\nimport { Layer } from \"./Layer\";\nimport { SpriteInstance, SpriteInstanceProps } from \"./SpriteInstance\";\nimport { DrawableProps } from \"./Drawable\";\nimport { Instance } from \"./Instance\";\n\n\ntype Int = number;\n\n\nexport type FrameProps = Omit<DrawableProps, 'id' | 'library'> & {\n    index:Int,\n    layer:Layer,\n    labelName?:string|undefined|null,\n}\n\n\nexport class Frame extends Drawable{\n\n    index:number\n    labelName:string|null;\n    layer:Layer;\n    instances:Array<ClipInstance|SpriteInstance> = [];\n    prev:Frame|undefined;\n    next:Frame|undefined;\n\n\n    constructor(props:FrameProps){\n        super({\n            ...props,\n            id: `${props.layer.id}.${props.index}`,\n            library: props.layer.library\n        });\n        \n        this.layer = props.layer;\n        this.index = props.index;\n        this.labelName = props.labelName || null;\n    }\n\n\n    public createClipInstance(props:Omit<ClipInstanceProps, 'frame'|'totalFrames'>){\n        const clipInstance = new ClipInstance({...props, frame:this, totalFrames:this.totalFrames})\n        this.instances.push(clipInstance)\n        return clipInstance;\n    }\n\n\n    public createSpriteInstance(props:Omit<SpriteInstanceProps, 'frame'|'totalFrames'>){\n        const spriteInstance = new SpriteInstance({...props, frame:this, totalFrames:this.totalFrames})\n        this.instances.push(spriteInstance)\n        return spriteInstance\n    }\n\n\n    public draw(frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float)=>void):void{\n        for(const instance of this.instances){\n            this.library.scene.draw(instance, frame, lerp, callback)\n        }\n    }\n\n}\n", "import { Clip } from \"./Clip\";\nimport { Drawable } from \"./Drawable\";\nimport { Frame, FrameProps } from \"./Frame\";\nimport { DrawableProps } from \"./Drawable\"\nimport { modWrap } from \"./util/math\";\n\n\ntype Int = number;\ntype Float = number;\n\n\nexport type LayerProps = Omit<DrawableProps, 'totalFrames'|'id'|'library'> & {\n    clip:Clip\n    type: 'Normal'|'Clipper',\n    clippedBy?:string|null,\n}\n\n\nexport class Layer extends Drawable{\n\n    public index:Int;\n    public type: LayerProps['type'];\n    public clippedBy:string|null;\n    public frames:Array<Frame>;\n    public framesByName:Record<string, Frame>;\n    public labels:Array<Frame>;\n    public clip:Clip;\n\n\n    constructor(props:LayerProps){\n        super({\n            ...props,\n            totalFrames:0,\n            id:`${props.clip.id}.${props.name}`,\n            library: props.clip.library,\n        });\n        \n        this.clip = props.clip;\n        this.type = props.type;\n        this.clippedBy = props.clippedBy || null;\n        this.index = this.clip.layers.length;\n        this.frames = [];\n        this.framesByName = {};\n        this.labels = [];\n    }\n\n\n    public createFrame(props:Omit<FrameProps, 'layer'>){\n        const frame = new Frame({...props, layer:this});\n\n        // TODO: Allow for more flexibility when adding frames\n        if(this.frames.length>0 && this.lastFrame.index+this.lastFrame.totalFrames != frame.index) throw(\"Must add next frame at previous frame.index+frame.duration\")\n\n        this.framesByName[frame.name] = frame;\n        if(frame.index+frame.totalFrames > this.totalFrames) this.totalFrames = frame.index+frame.totalFrames\n        if(frame.labelName){\n            this.labels.push(frame);\n        }\n        this.clip.__addFrame(frame);\n        /*\n        if(this.firstFrame){\n            this.firstFrame.prev = frame\n            frame.next = this.firstFrame\n        }\n        */\n        if(this.lastFrame){\n            this.lastFrame.next = frame\n            frame.prev = this.lastFrame\n        }\n        this.frames.push(frame)\n        return frame;\n    }\n\n\n    public get lastFrame(){\n        return this.frames[this.frames.length-1];\n    }\n\n\n    public get firstFrame(){\n        return this.frames[0];\n    }\n\n\n    public keyframeAt(frame:Float){\n        // TODO: Binary search would be a good optimisation here\n        frame = modWrap(frame, this.totalFrames);\n        for(const keyframe of this.frames){\n            if(keyframe.index<=frame && keyframe.index+keyframe.totalFrames > frame)\n            return keyframe;\n        }\n        return null;\n    }\n\n\n    public draw(frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void):void{\n        var keyframe = this.keyframeAt(frame)\n        if(keyframe!=null){\n            this.library.scene.draw(keyframe, frame, lerp, callback);\n        }\n    }\n\n}\n", "import { Drawable } from \"./Drawable\";\nimport { Frame } from \"./Frame\";\nimport { Layer, LayerProps } from \"./Layer\";\nimport { DrawableProps } from './Drawable'\nimport { modWrap } from \"./util/math\";\n\ntype Float = number;\nexport type ClipProps = Omit<DrawableProps, 'totalFrames'|'id'>\n\n\nexport class Clip extends Drawable{\n\n    layers:Array<Layer>;\n    layersById:Record<string, Layer>;\n    layersByName:Record<string, Layer>\n    framesById:Record<string, Frame>\n    framesByLabel:Record<string, Frame>\n\n\n    constructor(props:ClipProps){\n        super({\n            ...props,\n            totalFrames:0,\n            id:`${props.library.name}.clips.${props.name}`,\n        })\n        \n        this.layers = [];\n        this.layersById = {};\n        this.layersByName = {};\n        this.framesById = {};\n        this.framesByLabel = {};\n    }\n\n\n    public createLayer(props:Omit<LayerProps, 'clip'>){\n        const layer = new Layer({...props, clip:this});\n        this.layers.push(layer);\n        this.layersById[layer.id] = layer;\n        this.layersByName[layer.name] = layer;\n        if(layer.totalFrames > this.totalFrames) this.totalFrames = layer.totalFrames;\n\n        return layer;\n    }\n\n\n    __addFrame(frame:Frame){\n        this.framesById[frame.id] = frame;\n        if(frame.layer.totalFrames > this.totalFrames) this.totalFrames = frame.layer.totalFrames;\n        if(frame.labelName) this.framesByLabel[frame.labelName] = frame;\n    }\n\n\n    public draw(frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void){\n        for(const layer of this.layers){\n            if(layer.totalFrames==0) continue;\n            var f = modWrap(frame, layer.totalFrames);\n            if(layer.totalFrames>=f){\n                this.library.scene.draw(layer, frame, lerp, callback);\n            }\n        }\n    }\n\n   \n}", "import { Drawable } from \"./Drawable\";\nimport { Atlas } from \"./Atlas\";\nimport { DrawableProps } from \"./Drawable\"\n\ntype Int = number;\ntype Float = number;\n\n\nexport type SpriteProps = Omit<DrawableProps, 'totalFrames'|'library'|'id'> & {\n    x:Float,\n    y:Float,\n    width:Float,\n    height:Float,\n    rotated:boolean,\n    atlas:Atlas,\n}\n\n\nexport class Sprite extends Drawable{\n    x:Float;\n    y:Float;\n    width:Float;\n    height:Float;\n    rotated:boolean;\n    atlas:Atlas;\n\n    constructor(props:SpriteProps){\n        super({\n            ...props,\n            totalFrames:1,\n            library:props.atlas.library,\n            id:`${props.atlas.library.name}.sprites.${props.name}`\n        })\n        this.x = props.x;\n        this.y = props.y;\n        this.width = props.width;\n        this.height = props.height;\n        this.rotated = props.rotated;\n        this.atlas = props.atlas;\n    }\n\n\n    public getPixel(x:Float, y:Float, transform:DOMMatrix){\n        const point = new DOMPoint(x, y)\n        const imatrix = transform.inverse()\n        const local = point.matrixTransform(imatrix)\n\n        if(local.x<0 || local.x>=this.width) return null;\n        if(local.y<0 || local.y>=this.height) return null;\n\n        return this.atlas.getPixel(this.x + local.x, this.y + local.y)\n    }\n\n\n    public isSolidPixelAt(x:Float, y:Float, transform:DOMMatrix, alphaThreshold:number = 1){\n        const pixel = this.getPixel(x, y, transform)\n        return pixel && pixel[3] > alphaThreshold\n    }\n\n\n    public draw(frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void){\n        this.scene.drawImage(this.atlas.image, this.x, this.y, this.width, this.height, 0, 0, this.width, this.height)\n    }\n\n}\n", "import { Library } from \"./Library\";\nimport { Scene } from \"./Scene\";\nimport { Sprite } from \"./Sprite\";\n\n\nexport type AtlasProps = {\n    library:Library,\n    image:HTMLImageElement,\n    app:string,\n    version:string,\n    imagePath:string,\n    format:string,\n    size:{w:Float, h:Float},\n    resolution:string,\n    pixelData: ReturnType<Scene['getPixelData']>,\n}\n\n\nexport class Atlas{\n    library:Library;\n    sprites:Array<Sprite>;\n    image:HTMLImageElement;\n\n    app:string;\n    version:string;\n    imagePath:string;\n    format:string;\n    size:{w:Float, h:Float};\n    resolution:string;\n    pixelData: ReturnType<Scene['getPixelData']>;\n\n    \n    constructor(props:AtlasProps){\n        this.sprites = [];\n        this.library = props.library;\n        this.image = props.image;\n        this.app = props.app;\n        this.version = props.version;\n        this.imagePath = props.imagePath;\n        this.format = props.format;\n        this.size = props.size;\n        this.resolution = props.resolution;\n        this.pixelData = props.pixelData;\n\n        // this.library.scene.getPixelData(this.image) // TODO: Determine is this should be a lazy operation\n    }\n\n\n\n    getPixel(x:Float, y:Float){\n        x = Math.floor(x)\n        y = Math.floor(y)\n        \n        let i = x + (y*this.pixelData.imageData.width)\n\n        const data = this.pixelData.imageData.data\n        return [\n            data[(i*4) + 0],\n            data[(i*4) + 1],\n            data[(i*4) + 2],\n            data[(i*4) + 3],\n        ]\n    }\n\n\n}\n", "import { AnimationJson } from \"./AnimationJson\";\n\nconst keys:Record<string, string> = {\n    // Fix inconsistent names\n\n    // spritemap.json\n    SPRITE: \"sprite\",\n    SPRITES: \"sprites\",\n    ATLAS: \"atlas\",\n\n    // Animation.json\n    ANIMATION: \"animation\",\n    ATLAS_SPRITE_instance: \"atlasSpriteInstance\",\n    DecomposedMatrix: \"decomposedMatrix\",\n    Frames: \"frames\",\n    framerate: \"frameRate\",\n    Instance_Name: \"instanceName\",\n    Layer_name: \"layerName\",\n    Layer_type: \"layerType\",\n    Clipped_by: \"clippedBy\",\n    LAYERS: \"layers\",\n    Matrix3D: \"matrix3D\",\n    Position: \"position\",\n    Rotation: \"rotation\",\n    Scaling: \"scaling\",\n    SYMBOL_DICTIONARY: \"symbolDictionary\",\n    SYMBOL_Instance: \"symbolInstance\",\n    SYMBOL_name: \"symbolName\",\n    Symbols: \"symbols\",\n    TIMELINE: \"timeline\",\n\n\n    // Filter\n    GradientEntries: \"gradientEntries\",\n\n    // Color\n    RedMultiplier: 'redMultiplier',\n    AlphaOffset: 'alphaOffset',\n\n     // Animation.json optimised\n     AN: \"animation\",\n     AM: \"alphaMultiplier\",\n     ASI: \"atlasSpriteInstance\",\n     BM: \"bitmap\",\n     C: \"color\",\n     DU: \"duration\",\n     E: \"elements\",\n     FF: \"firstFrame\",\n     FR: \"frames\",\n     FRT: \"frameRate\",\n     I: \"index\",\n     IN: \"instanceName\",\n     L: \"layers\",\n     LN: \"layerName\",\n     LP: \"loop\",\n     M3D: \"matrix3D\",\n     MD: \"metadata\",\n     M: \"mode\",\n     N: \"name\",\n     POS: \"position\",\n     S: \"symbols\",\n     SD: \"symbolDictionary\",\n     SI: \"symbolInstance\",\n     SN: \"symbolName\",\n     ST: \"symbolType\",\n     TL: \"timeline\",\n     TRP: \"transformationPoint\",\n};\n\n\nfunction normaliseKey(key:string){\n    return keys[key] || key;\n}\n\n\n\n// AnimateCC exports wildy inconsistent JSON. Normalise the\n// fields to make it easier to work with\nexport function normaliseJson(data:any):any{\n    if(typeof data == \"string\" || typeof data == \"number\") return data\n    switch(typeof data){\n        case \"string\": return data;\n        case \"number\": return data;\n        case \"boolean\": return data;\n        case \"object\":\n            if(Array.isArray(data)){\n                return (data as Array<any>).map(normaliseJson);\n            }else{\n                var result:any = {};\n                Object.keys(data).forEach(key => result[normaliseKey(key)] = normaliseJson(data[key]));\n                return result;\n            }\n        case \"bigint\": throw(\"Not supported\");\n        case \"function\": throw(\"Not supported\");\n        case \"symbol\": throw(\"Not supported\");\n        case \"undefined\": throw(\"Not supported\");\n        default: throw(\"Unsupported\")\n    }\n}\n", "\nexport class Matrix{\n\n    _00:number; _01:number; _02:number; _03:number;\n    _10:number; _11:number; _12:number; _13:number;\n    _20:number; _21:number; _22:number; _23:number;\n    _30:number; _31:number; _32:number; _33:number;\n\n    data:Float32Array\n\n\n    constructor(\n        _00:number, _01:number, _02:number, _03:number,\n        _10:number, _11:number, _12:number, _13:number,\n        _20:number, _21:number, _22:number, _23:number,\n        _30:number, _31:number, _32:number, _33:number,\n    ){\n        this._00=_00; this._01=_01; this._02=_02; this._03=_03; \n        this._10=_10; this._11=_11; this._12=_12; this._13=_13; \n        this._20=_20; this._21=_21; this._22=_22; this._23=_23; \n        this._30=_30; this._31=_31; this._32=_32; this._33=_33; \n        \n        this.data = new Float32Array([\n            _00, _01, _02, _03,\n            _10, _11, _12, _13,\n            _20, _21, _22, _23,\n            _30, _31, _32, _33,\n        ])\n    }\n\n}", "export const createImage:(src:string)=>Promise<HTMLImageElement> = (src:string) =>\n    new Promise(resolve => {\n        const img = new Image();\n        img.src = src;\n        img.onload = () => resolve(img);\n        img.onerror = () => { throw(\"Image did not load: \" + img.src) }\n    });", "import { AnimationJson } from \"./json/AnimationJson\";\nimport { Clip, ClipProps } from \"./Clip\";\nimport { Vec2 } from \"./geom/Vec2\";\nimport { InstanceProps } from \"./Instance\";\nimport { Sprite, SpriteProps } from \"./Sprite\";\nimport { Atlas, AtlasProps } from \"./Atlas\";\nimport { normaliseJson } from \"./json/utilJson\";\nimport { Scene } from \"./Scene\";\nimport { Matrix } from \"./geom/Matrix\";\nimport { createImage } from \"./util/createImage\";\n\n\nexport class Library{\n\n    name:string;\n    path:string;\n    clips:Array<Clip> = [];\n    clipsByName:Record<string, Clip> = {};\n    spritesByName:Record<string, Sprite> = {};\n    atlases:Array<Atlas> = [];\n    atlasesBySpriteName:Record<string, Atlas> = {}\n    scene:Scene;\n    \n    \n    constructor(name:string, path:string, scene:Scene){\n        this.name = name;\n        this.path = path;\n        this.atlases = [];\n        this.scene = scene;\n    }\n\n\n    symbol(name:string){\n        if(this.clipsByName[name]) return this.clipsByName[name]\n        if(this.spritesByName[name]) return this.spritesByName[name]\n        throw(\"Cannot find symbol: \" + name + \" for library: \" + this.path);\n    }\n\n\n    createAtlas(props:Omit<AtlasProps, 'library'|'pixelData'>, pixelData:ReturnType<Scene['getPixelData']>){\n        const atlas = new Atlas({...props, library:this, pixelData});\n        this.atlases.push(atlas);\n        return atlas;\n    }\n\n\n    createSprite(atlas:Atlas, props:Omit<SpriteProps, 'atlas'>){\n        const sprite = new Sprite({...props, atlas:atlas})\n        atlas.sprites.push(sprite);\n        this.spritesByName[sprite.name] = sprite;\n        this.atlasesBySpriteName[sprite.name] = atlas;\n        return sprite;\n    }\n\n\n    createClip(props:Omit<ClipProps, 'library'>){\n        const clip = new Clip({...props, library:this});\n        this.clips.push(clip)\n        this.clipsByName[clip.name] = clip\n        return clip;\n    }\n\n\n    public async loadData(){\n        const animJsonPath = this.path + \"/Animation.json\";\n        const animFetchResult = await fetch(animJsonPath);\n        const dataRaw:AnimationJson = await animFetchResult.json();\n        const data = normaliseJson(dataRaw) as AnimationJson;\n        const spriteNames:Array<string> = [];\n\n        // Clip\n        for(const symbolData of data.symbolDictionary.symbols){\n            const clip = this.createClip({\n                name: symbolData.symbolName,\n            })\n\n            // Layer\n            for(let l=symbolData.timeline.layers.length-1; l>=0; l--){\n                const layerData = symbolData.timeline.layers[l]\n                const layer = clip.createLayer({\n                    name: layerData.layerName,\n                    type: layerData.layerType || 'Normal',\n                    clippedBy: layerData.clippedBy || null,\n                })\n\n                // Frame\n                for(const frameData of layerData.frames){\n                    const frame = layer.createFrame({\n                        name: \"\"+frameData.index,\n                        totalFrames: frameData.duration,\n                        labelName: frameData.name,\n                        index: frameData.index,\n                    })\n\n                    // Element\n                    for(const elemInstanceData of  frameData.elements){\n                        if(\"symbolInstance\" in elemInstanceData){\n                            const elemData = elemInstanceData.symbolInstance;\n                            const m = elemData.matrix3D;\n\n                            const instanceProps:Omit<InstanceProps, 'totalFrames'>  = {\n                                frame,\n                                name: frame.name,\n                                filters: elemData.filters || null,\n                                matrix: 'm00' in m ? new Matrix(m.m00, m.m01, m.m02, m.m03,\n                                                                    m.m10, m.m11, m.m12, m.m13,\n                                                                    m.m20, m.m21, m.m22, m.m23,\n                                                                    m.m30, m.m31, m.m32, m.m33)\n                                                     : new Matrix(m[ 0], m[ 1], m[ 2], m[ 3],\n                                                                    m[ 4], m[ 5], m[ 6], m[ 7],\n                                                                    m[ 8], m[ 9], m[10], m[11],\n                                                                    m[12], m[13], m[14], m[15]),\n                                itemName: elemData.symbolName,\n                                color: elemData.color || null,\n                                //position: new Vec3(elemData.decomposedMatrix.position),\n                                //scale: new Vec3(elemData.decomposedMatrix.scaling),\n                                //rotation: new Vec3(elemData.decomposedMatrix.rotation),\n                            }\n\n                            const clipInstance = frame.createClipInstance({\n                                ...instanceProps,\n                                transformationPoint: new Vec2(elemData.transformationPoint),\n                                behaviour: elemData.symbolType == \"graphic\"\n                                         ? { type: 'graphic', loop: elemData.loop, firstFrame: elemData.firstFrame}\n                                         : { type: 'movieclip' }\n                            })\n                        }else{\n                            const elemData = elemInstanceData.atlasSpriteInstance;\n                            const m = elemData.matrix3D;\n\n                            const spriteInstance = frame.createSpriteInstance({\n                                name: frame.name,\n                                filters: elemData.filters || null,\n                                color: null,\n                                matrix: 'm00' in m ? new Matrix(m.m00, m.m01, m.m02, m.m03,\n                                                                    m.m10, m.m11, m.m12, m.m13,\n                                                                    m.m20, m.m21, m.m22, m.m23,\n                                                                    m.m30, m.m31, m.m32, m.m33)\n                                                     : new Matrix(m[ 0], m[ 1], m[ 2], m[ 3],\n                                                                    m[ 4], m[ 5], m[ 6], m[ 7],\n                                                                    m[ 8], m[ 9], m[10], m[11],\n                                                                    m[12], m[13], m[14], m[15]),\n                                itemName: elemData.name,\n                                //position: new Vec3(elemData.decomposedMatrix.position),\n                                //scale: new Vec3(elemData.decomposedMatrix.scaling),\n                                //rotation: new Vec3(elemData.decomposedMatrix.rotation),\n                            })\n\n                            if(spriteNames.indexOf(spriteInstance.itemName)==-1) spriteNames.push(spriteInstance.itemName)\n                        }\n                    }\n                }\n            }\n        };\n\n        // Sprites\n        let pendingAtlasIndex = 1;\n        for(const spriteName of spriteNames){\n            if(this.atlasesBySpriteName[spriteName]==null){\n                const spriteJsonPath = this.path + `/spritemap${pendingAtlasIndex}.json`;\n                const altasFetch = await fetch(spriteJsonPath);\n                const dataRaw:SpriteMapJson = await altasFetch.json();\n                const data = normaliseJson(dataRaw) as SpriteMapJson;\n\n                const imagePath = this.path + `/spritemap${pendingAtlasIndex}.png`;\n                const image = await createImage(imagePath) // TODO: This will impact load times. Find a way to make this load parallel. Workers?\n\n                \n                const atlas = this.createAtlas({\n                    image,\n                    app: data.meta.app,\n                    version: data.meta.version,\n                    imagePath: data.meta.image,\n                    format: data.meta.format,\n                    size: data.meta.size,\n                    resolution: data.meta.resolution ,\n                }, this.scene.getPixelData(image),)\n                for(const spriteSpriteData of data.atlas.sprites){\n                    const spriteData = spriteSpriteData.sprite;\n                    const sprite = this.createSprite(atlas, {\n                        name: spriteData.name,\n                        x: spriteData.x,\n                        y: spriteData.y,\n                        width: spriteData.w,\n                        height: spriteData.h,\n                        rotated: spriteData.rotated,\n                    })\n                    this.atlasesBySpriteName[sprite.name] = atlas;\n                }\n\n\n                pendingAtlasIndex++;\n            }\n        }\n\n    }\n\n\n}\n", "import { Drawable } from \"./Drawable\";\nimport { Library } from \"./Library\";\n\n\nexport class Scene{\n\n    draw: (item:Drawable, frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void) => void\n    drawImage: (image:HTMLImageElement, sx:number, sy:number, sw:number, sh:number, rx:number, ry:number, rw:number, rh:number) => void\n    pixelData:Record<string, { ctx:CanvasRenderingContext2D, imageData:ImageData, image:HTMLImageElement }>\n\n\n    constructor(){\n        this.draw = null! // OVERRIDE THIS IN THE BASE CLASS!\n        this.drawImage = null!\n        this.pixelData = {}\n    }\n\n\n    get mouseX():number{\n        throw(\"Override mouseX in base class\")\n    }\n\n\n    get mouseY():number{\n        throw(\"Override mouseY in base class\")\n    }\n\n  \n    createLibrary(name:string, path:string){\n        const library = new Library(name, path, this);\n        return library;\n    }\n\n\n    getPixelData(image:HTMLImageElement){\n        if(image.complete==false) throw(\"Image has not loaded!\")\n\n        const canvas = document.createElement('canvas')\n        canvas.width = image.width\n        canvas.height = image.height\n        const ctx = document.createElement('canvas').getContext('2d')!\n        ctx.drawImage(image, 0, 0);\n\n        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)\n\n        return {\n            ctx,\n            imageData,\n            image,\n        }\n    }\n\n\n}", "import { Clip as ClipBase } from './core/Clip'\nimport { Layer as LayerBase } from './core/Layer'\nimport { Frame as FrameBase } from './core/Frame'\nimport { Instance as InstanceBase } from './core/Instance'\nimport { SpriteInstance as SpriteInstanceBase } from './core/SpriteInstance'\nimport { ClipInstance as ClipInstanceBase } from './core/ClipInstance'\nimport { Sprite as SpriteBase } from './core/Sprite'\nimport { Canvas2dScene as Canvas2dAnimationContextBase } from './Canvas2dScene'\n\nexport const Clip = ClipBase\nexport const Layer = LayerBase\nexport const Frame = FrameBase\nexport const Instance = InstanceBase\nexport const SpriteInstance = SpriteInstanceBase\nexport const ClipInstance = ClipInstanceBase\nexport const Sprite = SpriteBase\nexport const Canvas2dAnimationContext = Canvas2dAnimationContextBase\n", "import { Layer } from \".\";\nimport { Scene } from \"./core/Scene\"\nimport { ClipInstance } from \"./core/ClipInstance\";\nimport { Drawable } from \"./core/Drawable\"\nimport { Frame } from \"./core/Frame\";\nimport { Instance } from \"./core/Instance\"\nimport { Sprite } from \"./core/Sprite\"\nimport { SpriteInstance } from \"./core/SpriteInstance\";\nimport { modWrap } from \"./core/util/math\";\n\n\nexport class DomScene extends Scene{\n    \n    elemId:string\n    elems:Array<HTMLElement>\n    stack:Array<HTMLElement>\n    \n\n    constructor(elemId:string){\n        super();\n        this.elemId = elemId\n        this.elems = []\n        this.stack = [this.container]\n    }\n\n\n    get current(){\n        return this.stack[this.stack.length-1] as HTMLDivElement\n    }\n\n\n\n    pushElem(type:string, name:string, id:string){\n        const elem = document.createElement('div');\n        elem.className = `anim anim-${type} anim-of-${name}`\n        elem.style.position = 'absolute'\n        elem.style.top = '0px'\n        elem.style.left = '0px'\n        elem.style.width = '0px'\n        elem.style.height = '0px'\n        this.current.appendChild(elem)\n        this.elems.push(elem)\n        this.stack.push(elem)\n    }\n\n\n    pop(){\n        this.stack.pop()\n    }\n\n\n    get container(){\n        return document.getElementById(this.elemId) as HTMLDivElement\n    }\n\n\n    clear(){\n        while(this.elems.length > 0){\n            const elem = this.elems.shift()!;\n            elem.remove();\n        }\n    }\n\n\n    draw = (item:Drawable, frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void) => {\n        if(!this.container) return;\n        if(item instanceof Layer){\n            this.pushElem('layer', item.name, item.id)\n            if(callback) callback(item, frame, lerp)\n            else item.draw(frame, lerp, callback)\n            this.pop()\n        }else if(item instanceof Frame){\n            this.pushElem('frame', item.name, item.id)\n            if(callback) callback(item, frame, lerp)\n            else item.draw(frame, lerp, callback)\n            this.pop()\n        }else if(item instanceof SpriteInstance){\n            this.pushElem('sprite', item.name, item.id)\n            this.transformInstance(item, frame, lerp)\n            if(callback) callback(item, frame, lerp)\n            else item.draw(frame, lerp, callback)\n            this.pop()\n        }else if(item instanceof ClipInstance){\n            this.pushElem('clip', item.name, item.id)\n            this.transformInstance(item, frame, lerp)\n            if(callback) callback(item, frame, lerp)\n            else item.draw(frame, lerp, callback)\n            this.pop()\n        }else if(item instanceof Sprite){\n            this.current.style.width = item.width + 'px'\n            this.current.style.height = item.height + 'px'\n            this.current.style.backgroundImage = `url(${item.atlas.image.src})`\n            this.current.style.backgroundPosition = `${-item.x}px ${-item.y}px`\n            //this.current.style.border = '1px solid red'\n        }else{\n            if(callback) callback(item, frame, lerp)\n            else item.draw(frame, lerp, callback)\n        }\n    }\n\n\n    pushTranslate(x:string, y:string){\n        this.pushElem('transform', 'translate', '__transform__')\n        this.current.style.transform = `translate(${x}, ${y})`\n    }\n\n\n    pushScale(x:string, y:string){\n        this.pushElem('transform', 'scale', '__scale__')\n        this.current.style.transform = `scale(${x}, ${y})`\n    }\n\n    pushRotation(z:string){\n        this.pushElem('transform', 'rotation', '__rotation__')\n        this.current.style.transform = `rotate(${z})`\n    }\n    \n\n    transformInstance(item:Instance, frame:Float, lerp?:boolean){\n        /*\n        const m = item.matrix2d\n        if(lerp && item.next){\n            const t = (modWrap(frame, item.totalFrames)-item.index) / item.frame.totalFrames;\n            const m1 = item.matrix2d\n            const m2 = item.next.matrix2d \n            this.current.style.transform = `matrix(${m1.a + (m2.a-m1.a)*t}, ${m1.b + (m2.b-m1.b)*t}, ${m1.c + (m2.c-m1.c)*t}, ${m1.d + (m2.d-m1.d)*t}, ${m1.e + (m2.e-m1.e)*t}, ${m1.f + (m2.f-m1.f)*t})`\n        }else{\n            this.current.style.transform = `matrix(${m.a}, ${m.b}, ${m.c}, ${m.d}, ${m.e}, ${m.f})`\n       }\n        */\n       const m = item.matrix3d;\n       this.current.style.transform = `matrix3d(${m._00}, ${m._01}, ${m._02}, ${m._03}, ${m._10}, ${m._11}, ${m._12}, ${m._13}, ${m._20}, ${m._21}, ${m._22}, ${m._23}, ${m._30}, ${m._31}, ${m._32}, ${m._33})`\n    }\n\n}", "import { Layer } from \"..\";\nimport { Drawable } from \"../core/Drawable\";\nimport { DomScene } from \"../DomScene\";\n\n// Set up animation context and animation libraries\nconst scene = new DomScene('anim')\nconst testLibrary = scene.createLibrary('test', './test')\n\n\nasync function init(){\n    await testLibrary.loadData();\n    update();\n}\n\nlet frame = 0;\nlet play = true;\nlet swap = false;\n\nconst btnPause = document.getElementById('btn-pause')!\nconst btnSwap = document.getElementById('btn-swap')!\nbtnPause.onclick = () => {\n    play = !play;\n    btnPause.innerText = play ? \"Pause\" : \"Play\"\n    let gunInput = document.getElementById(\"gun-input\");\n    if(gunInput){\n        gunInput.focus();\n    }\n}\nbtnSwap.onclick = () => {\n    swap = !swap;\n}\n\nlet gunInput = document.createElement('input')\ngunInput.id = \"gun-input\"\ngunInput.value = \"GUN!!!!\"\ngunInput.style.boxShadow = '0px 3px 8px rgb(0 0 0 / 40%)'\ngunInput.style.position = 'absolute'\ngunInput.style.top = '-10px'\ngunInput.style.left = '-100px'\ngunInput.style.width = '150px'\ngunInput.style.height = '30px'\n\nlet shellInput = document.createElement('input')\nshellInput.type = 'checkbox'\nshellInput.id = \"shell-input\"\nshellInput.style.position = 'absolute'\nshellInput.style.width = '30px'\nshellInput.style.height = '30px'\nshellInput.style.transform = 'translate(-50%, -50%)'\nshellInput.checked = true;\n\n\nfunction drawWithLogic(item:Drawable, frame:number, lerp?:boolean){\n    if(swap && item.name==\"Shell\"){\n        scene.current.appendChild(shellInput)\n    }else if(swap && item.name==\"stardude_assets/StarGuyGun\"){\n        scene.current.appendChild(gunInput)\n    }else{\n        item.draw(frame, lerp, drawWithLogic)\n    }\n}\n\nfunction update(){\n    if(play){\n        scene.clear();\n\n        scene.pushTranslate('0px', '10px')\n        scene.pushScale('1', '1')\n        scene.pushRotation('0deg')\n        testLibrary.symbol(\"StarDude\").draw(frame, false, drawWithLogic)\n        scene.pop();\n        scene.pop();\n        scene.pop();\n\n        scene.pushTranslate('100px', '10px')\n        scene.pushScale('1', '1')\n        scene.pushRotation('0deg')\n        testLibrary.symbol(\"Walker_Laser_Rotating\").draw(frame, false, drawWithLogic)\n        scene.pop();\n        scene.pop();\n        scene.pop();\n\n        frame += 1;\n    }\n\n    requestAnimationFrame(update)\n}\n\n\n\n\ninit();\n"],
  "mappings": "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",
  "names": []
}
