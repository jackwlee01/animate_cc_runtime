{
  "version": 3,
  "sources": ["../src/examples/example-utils.ts", "../src/core/Drawable.ts", "../src/core/geom/Vec2.ts", "../src/core/geom/Matrix.ts", "../src/core/Instance.ts", "../src/core/util/math.ts", "../src/core/ClipInstance.ts", "../src/core/SpriteInstance.ts", "../src/core/Frame.ts", "../src/core/Layer.ts", "../src/core/Clip.ts", "../src/core/Sprite.ts", "../src/core/Atlas.ts", "../src/core/json/utilJson.ts", "../src/core/util/createImage.ts", "../src/core/Library.ts", "../src/core/Scene.ts", "../src/Canvas2dScene.ts", "../src/examples/minimal.ts"],
  "sourcesContent": ["import { Clip } from \"../core/Clip\";\nimport { Library } from \"../core/Library\";\n\n\nexport function setupCanvas(canvas:HTMLCanvasElement) {\n    // Set the context quality and smoothing\n    const ctx = canvas.getContext('2d')!\n    ctx.imageSmoothingEnabled = true;\n    ctx.imageSmoothingQuality = 'high'\n\n    // Set the canvas according to window width\n    var bodyRec = document.body.getBoundingClientRect();\n    canvas.width = Math.min(1000, bodyRec.width - 8);\n    canvas.height = canvas.width;\n\n    // Get the device pixel ratio, falling back to 1.\n    let dpr = window.devicePixelRatio || 1;\n\n    // Get the size of the canvas in CSS pixels.\n    let rect = canvas.getBoundingClientRect();\n    \n    // Give the canvas pixel dimensions of their CSS\n    // size * the device pixel ratio.\n    //canvas.style.border = \"2px solid gray\";\n    canvas.style.width = \"\" + canvas.width + \"px\";\n    canvas.style.height = \"\" + canvas.height + \"px\";\n    canvas.width = rect.width * dpr;\n    canvas.height = rect.height * dpr;\n\n    return dpr;\n}\n\n\n\nexport function addExampleButtons(libraryKey:string, libs:Record<string, Library>, onLibrarySelected:(nextLibrary:Library)=>void, onSymbolPicked:(nextSymbol:Clip)=>void, onMinus:()=>void, onPlus:()=>void){\n    const library = libs[libraryKey]\n    const buttons = document.getElementById(\"buttons\")!\n\n    const selector = document.createElement('select')\n    selector.value = libraryKey\n    selector.onchange = (e) => {\n        const buttons = document.getElementById('buttons')!\n        while(buttons.childNodes.length > 0) buttons.childNodes[0].remove();\n        addExampleButtons(selector.value, libs, onLibrarySelected, onSymbolPicked, onMinus, onPlus)\n        onLibrarySelected(libs[selector.value])\n    }\n    buttons.appendChild(selector)\n    for(const libraryName of Object.keys(libs)){\n        const option = document.createElement('option')\n        option.value = libraryName\n        option.selected = libraryName == libraryKey\n        option.innerText = libraryName\n        selector.appendChild(option)\n    }\n\n    const minusButton = document.createElement('button')\n    minusButton.innerHTML = '-'\n    minusButton.onclick = onMinus\n    buttons.appendChild(minusButton);\n\n    const plusButton = document.createElement('button')\n    plusButton.innerHTML = '+'\n    plusButton.onclick = onPlus\n    buttons.appendChild(plusButton);\n\n    for(const clip of library.clips){\n        if(clip.name.indexOf(\"/\")!=-1 || clip.name.indexOf(\"Symbol \")==0 || clip.name.indexOf(\"Tween \")==0 || clip.name.indexOf(\"/Symbol \")!=-1 || clip.name.indexOf(\"/Tween \")!=-1) continue;\n        var button = document.createElement(\"button\")\n        button.innerHTML = clip.name\n        button.onclick = () => onSymbolPicked(clip)\n        buttons.appendChild(button)\n    }\n}", "import { Library } from \"./Library\";\n\ntype Int = number;\ntype Float = number;\n\n\nexport type DrawableProps = {\n    name:string,\n    id:string,\n    totalFrames:Int,\n    library:Library;\n}\n\n\nexport abstract class Drawable{\n    name:string;\n    id:string;\n    totalFrames:Int = 1;\n    library:Library;\n\n\n    constructor(props:DrawableProps){\n        this.name = props.name;\n        this.id = props.id;\n        this.totalFrames = props.totalFrames;\n        this.library = props.library;\n    }\n\n\n    public get scene(){\n        return this.library.scene;\n    }\n\n\n    public draw(frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void){\n        // Override in base class\n    }\n\n}", "type Float = number;\n\n\nexport class Vec2 {\n\n    x:Float\n    y:Float\n    data:Float32Array\n\n    \n    constructor(props:{x:Float, y:Float}){\n        this.x = props.x\n        this.y = props.y\n        this.data = new Float32Array([this.x, this.y])\n    }\n    \n}", "\nexport class Matrix{\n\n    _00:number; _01:number; _02:number; _03:number;\n    _10:number; _11:number; _12:number; _13:number;\n    _20:number; _21:number; _22:number; _23:number;\n    _30:number; _31:number; _32:number; _33:number;\n\n    data:Float32Array\n\n\n    constructor(\n        _00:number, _01:number, _02:number, _03:number,\n        _10:number, _11:number, _12:number, _13:number,\n        _20:number, _21:number, _22:number, _23:number,\n        _30:number, _31:number, _32:number, _33:number,\n    ){\n        this._00=_00; this._01=_01; this._02=_02; this._03=_03; \n        this._10=_10; this._11=_11; this._12=_12; this._13=_13; \n        this._20=_20; this._21=_21; this._22=_22; this._23=_23; \n        this._30=_30; this._31=_31; this._32=_32; this._33=_33; \n        \n        this.data = new Float32Array([\n            _00, _01, _02, _03,\n            _10, _11, _12, _13,\n            _20, _21, _22, _23,\n            _30, _31, _32, _33,\n        ])\n    }\n\n}", "import { Drawable } from \"./Drawable\";\nimport { Frame } from \"./Frame\";\nimport { DrawableProps } from './Drawable'\nimport { Matrix } from \"./geom/Matrix\";\nimport { Color, Filters } from \"./json/AnimationJson\";\n\n\nexport type InstanceProps = Omit<DrawableProps, 'id' | 'library'> & {\n    itemName:string,\n    matrix?:Matrix,\n    frame:Frame,\n    filters?:Filters|null,\n    color?:Color|null,\n    //position:Vec3,\n    //scale:Vec3,\n    //rotation:Vec3,\n}\n\n\nexport class Instance extends Drawable{\n\n    matrix:Matrix;\n    frame:Frame;\n    index:number;\n    itemName:string;\n    filters:Filters|null;\n    color:Color|null;\n    //position:Vec3;\n    //scale:Vec3;\n    //rotation:Vec3;\n    //filters = new Array<Filter>();\n\n    \n    constructor(props:InstanceProps){\n        super({\n            ...props,\n            library: props.frame.library,\n            id: `${props.frame.id}.${props.frame.instances.length}`,\n        });\n\n        this.itemName = props.itemName;\n        this.matrix = props.matrix || new Matrix(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n        this.filters = props.filters || null;\n        this.color = props.color || null;\n        //this.position = props.position;\n        //this.scale = props.scale;\n        //this.rotation = props.rotation;\n        this.frame = props.frame;\n        this.index = this.frame.instances.length;\n    }\n\n\n    public get prev():Instance|undefined{\n        const item = this.frame.prev?.instances[this.index]\n        return item?.itemName==this.itemName ? item : undefined \n    }\n\n\n    public get next():Instance|undefined{\n        const item = this.frame.next?.instances[this.index]\n        return item?.itemName==this.itemName ? item : undefined\n    }\n\n\n    public get item():Drawable{\n        throw(\"Override item getter in base class\");\n    }\n\n\n    public draw(frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void):void{\n        this.library.scene.draw(this.item, frame, lerp, callback)\n    }\n\n\n}", "\nexport function modWrap(a:number, b:number){\n    return a - b * Math.floor(a/b);\n}\n", "import { Drawable } from \"./Drawable\";\nimport { Vec2 } from \"./geom/Vec2\";\nimport { Instance } from \"./Instance\";\nimport { InstanceProps } from \"./Instance\"\nimport { modWrap } from \"./util/math\";\n\ntype LoopKind = 'loop' // TODO: HANDLE OTHER LOOP KINDS | 'PlayOnce' | 'SingleFrame' | 'PlayOnceReverse' | 'LoopReverse'\n\n\ntype ClipInstanceBehavior = {\n    type: 'graphic'\n    loop:LoopKind;\n    firstFrame:Float;\n} | {\n    type: 'movieclip'\n}\n\n\nexport type ClipInstanceProps = InstanceProps & { \n    transformationPoint?:Vec2,   \n    behaviour?:ClipInstanceBehavior\n}\n\n\nexport class ClipInstance extends Instance{\n\n    transformationPoint:Vec2\n    behaviour:ClipInstanceBehavior\n    \n    \n    constructor(props:ClipInstanceProps){\n        super(props);\n        this.behaviour = props.behaviour || { type: 'movieclip' };\n        this.transformationPoint = props.transformationPoint || new Vec2({x:0, y:0});\n    }\n\n\n    public get item(){\n        return this.library.clipsByName[this.itemName];\n    }\n\n\n    public draw(frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void):void{\n        if(this.behaviour.type == 'graphic'){\n            frame = this.behaviour.firstFrame + modWrap(frame, 1);\n        }\n        this.library.scene.draw(this.item, frame, lerp, callback)\n    }\n\n\n}\n", "import { Instance, InstanceProps } from \"./Instance\";\n\ntype Float = number;\n\nexport type SpriteInstanceProps = InstanceProps & {\n\n}\n\n\nexport class SpriteInstance extends Instance{\n\n    constructor(props:SpriteInstanceProps){\n        super(props)\n    }\n\n    \n    public get item(){\n        return this.library.spritesByName[this.itemName];\n    }\n\n\n}\n", "import { ClipInstance, ClipInstanceProps } from \"./ClipInstance\";\nimport { Drawable } from \"./Drawable\";\nimport { Layer } from \"./Layer\";\nimport { SpriteInstance, SpriteInstanceProps } from \"./SpriteInstance\";\nimport { DrawableProps } from \"./Drawable\";\nimport { Instance } from \"./Instance\";\n\n\ntype Int = number;\n\n\nexport type FrameProps = Omit<DrawableProps, 'id' | 'library'> & {\n    index:Int,\n    layer:Layer,\n    labelName?:string|undefined|null,\n}\n\n\nexport class Frame extends Drawable{\n\n    index:number\n    labelName:string|null;\n    layer:Layer;\n    instances:Array<ClipInstance|SpriteInstance> = [];\n    prev:Frame|undefined;\n    next:Frame|undefined;\n\n\n    constructor(props:FrameProps){\n        super({\n            ...props,\n            id: `${props.layer.id}.${props.index}`,\n            library: props.layer.library\n        });\n        \n        this.layer = props.layer;\n        this.index = props.index;\n        this.labelName = props.labelName || null;\n    }\n\n\n    public createClipInstance(props:Omit<ClipInstanceProps, 'frame'|'totalFrames'>){\n        const clipInstance = new ClipInstance({...props, frame:this, totalFrames:this.totalFrames})\n        this.instances.push(clipInstance)\n        return clipInstance;\n    }\n\n\n    public createSpriteInstance(props:Omit<SpriteInstanceProps, 'frame'|'totalFrames'>){\n        const spriteInstance = new SpriteInstance({...props, frame:this, totalFrames:this.totalFrames})\n        this.instances.push(spriteInstance)\n        return spriteInstance\n    }\n\n\n    public draw(frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float)=>void):void{\n        for(const instance of this.instances){\n            this.library.scene.draw(instance, frame, lerp, callback)\n        }\n    }\n\n}\n", "import { Clip } from \"./Clip\";\nimport { Drawable } from \"./Drawable\";\nimport { Frame, FrameProps } from \"./Frame\";\nimport { DrawableProps } from \"./Drawable\"\nimport { modWrap } from \"./util/math\";\n\n\ntype Int = number;\ntype Float = number;\n\n\nexport type LayerProps = Omit<DrawableProps, 'totalFrames'|'id'|'library'> & {\n    clip:Clip\n    type: 'Normal'|'Clipper',\n    clippedBy?:string|null,\n}\n\n\nexport class Layer extends Drawable{\n\n    public index:Int;\n    public type: LayerProps['type'];\n    public clippedBy:string|null;\n    public frames:Array<Frame>;\n    public framesByName:Record<string, Frame>;\n    public labels:Array<Frame>;\n    public clip:Clip;\n\n\n    constructor(props:LayerProps){\n        super({\n            ...props,\n            totalFrames:0,\n            id:`${props.clip.id}.${props.name}`,\n            library: props.clip.library,\n        });\n        \n        this.clip = props.clip;\n        this.type = props.type;\n        this.clippedBy = props.clippedBy || null;\n        this.index = this.clip.layers.length;\n        this.frames = [];\n        this.framesByName = {};\n        this.labels = [];\n    }\n\n\n    public createFrame(props:Omit<FrameProps, 'layer'>){\n        const frame = new Frame({...props, layer:this});\n\n        // TODO: Allow for more flexibility when adding frames\n        if(this.frames.length>0 && this.lastFrame.index+this.lastFrame.totalFrames != frame.index) throw(\"Must add next frame at previous frame.index+frame.duration\")\n\n        this.framesByName[frame.name] = frame;\n        if(frame.index+frame.totalFrames > this.totalFrames) this.totalFrames = frame.index+frame.totalFrames\n        if(frame.labelName){\n            this.labels.push(frame);\n        }\n        this.clip.__addFrame(frame);\n        /*\n        if(this.firstFrame){\n            this.firstFrame.prev = frame\n            frame.next = this.firstFrame\n        }\n        */\n        if(this.lastFrame){\n            this.lastFrame.next = frame\n            frame.prev = this.lastFrame\n        }\n        this.frames.push(frame)\n        return frame;\n    }\n\n\n    public get lastFrame(){\n        return this.frames[this.frames.length-1];\n    }\n\n\n    public get firstFrame(){\n        return this.frames[0];\n    }\n\n\n    public keyframeAt(frame:Float){\n        // TODO: Binary search would be a good optimisation here\n        frame = modWrap(frame, this.totalFrames);\n        for(const keyframe of this.frames){\n            if(keyframe.index<=frame && keyframe.index+keyframe.totalFrames > frame)\n            return keyframe;\n        }\n        return null;\n    }\n\n\n    public draw(frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void):void{\n        var keyframe = this.keyframeAt(frame)\n        if(keyframe!=null){\n            this.library.scene.draw(keyframe, frame, lerp, callback);\n        }\n    }\n\n}\n", "import { Drawable } from \"./Drawable\";\nimport { Frame } from \"./Frame\";\nimport { Layer, LayerProps } from \"./Layer\";\nimport { DrawableProps } from './Drawable'\nimport { modWrap } from \"./util/math\";\n\ntype Float = number;\nexport type ClipProps = Omit<DrawableProps, 'totalFrames'|'id'>\n\n\nexport class Clip extends Drawable{\n\n    layers:Array<Layer>;\n    layersById:Record<string, Layer>;\n    layersByName:Record<string, Layer>\n    framesById:Record<string, Frame>\n    framesByLabel:Record<string, Frame>\n\n\n    constructor(props:ClipProps){\n        super({\n            ...props,\n            totalFrames:0,\n            id:`${props.library.name}.clips.${props.name}`,\n        })\n        \n        this.layers = [];\n        this.layersById = {};\n        this.layersByName = {};\n        this.framesById = {};\n        this.framesByLabel = {};\n    }\n\n\n    public createLayer(props:Omit<LayerProps, 'clip'>){\n        const layer = new Layer({...props, clip:this});\n        this.layers.push(layer);\n        this.layersById[layer.id] = layer;\n        this.layersByName[layer.name] = layer;\n        if(layer.totalFrames > this.totalFrames) this.totalFrames = layer.totalFrames;\n\n        return layer;\n    }\n\n\n    __addFrame(frame:Frame){\n        this.framesById[frame.id] = frame;\n        if(frame.layer.totalFrames > this.totalFrames) this.totalFrames = frame.layer.totalFrames;\n        if(frame.labelName) this.framesByLabel[frame.labelName] = frame;\n    }\n\n\n    public draw(frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void){\n        for(const layer of this.layers){\n            if(layer.totalFrames==0) continue;\n            var f = modWrap(frame, layer.totalFrames);\n            if(layer.totalFrames>=f){\n                this.library.scene.draw(layer, frame, lerp, callback);\n            }\n        }\n    }\n\n   \n}", "import { Drawable } from \"./Drawable\";\nimport { Atlas } from \"./Atlas\";\nimport { DrawableProps } from \"./Drawable\"\n\ntype Int = number;\ntype Float = number;\n\n\nexport type SpriteProps = Omit<DrawableProps, 'totalFrames'|'library'|'id'> & {\n    x:Float,\n    y:Float,\n    width:Float,\n    height:Float,\n    rotated:boolean,\n    atlas:Atlas,\n}\n\n\nexport class Sprite extends Drawable{\n    x:Float;\n    y:Float;\n    width:Float;\n    height:Float;\n    rotated:boolean;\n    atlas:Atlas;\n\n    constructor(props:SpriteProps){\n        super({\n            ...props,\n            totalFrames:1,\n            library:props.atlas.library,\n            id:`${props.atlas.library.name}.sprites.${props.name}`\n        })\n        this.x = props.x;\n        this.y = props.y;\n        this.width = props.width;\n        this.height = props.height;\n        this.rotated = props.rotated;\n        this.atlas = props.atlas;\n    }\n\n\n    public getPixel(x:Float, y:Float, transform:DOMMatrix){\n        const point = new DOMPoint(x, y)\n        const imatrix = transform.inverse()\n        const local = point.matrixTransform(imatrix)\n\n        if(local.x<0 || local.x>=this.width) return null;\n        if(local.y<0 || local.y>=this.height) return null;\n\n        return this.atlas.getPixel(this.x + local.x, this.y + local.y)\n    }\n\n\n    public isSolidPixelAt(x:Float, y:Float, transform:DOMMatrix, alphaThreshold:number = 1){\n        const pixel = this.getPixel(x, y, transform)\n        return pixel && pixel[3] > alphaThreshold\n    }\n\n\n    public draw(frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void){\n        this.scene.drawImage(this.atlas.image, this.x, this.y, this.width, this.height, 0, 0, this.width, this.height)\n    }\n\n}\n", "import { Library } from \"./Library\";\nimport { Scene } from \"./Scene\";\nimport { Sprite } from \"./Sprite\";\n\n\nexport type AtlasProps = {\n    library:Library,\n    image:HTMLImageElement,\n    app:string,\n    version:string,\n    imagePath:string,\n    format:string,\n    size:{w:Float, h:Float},\n    resolution:string,\n    pixelData: ReturnType<Scene['getPixelData']>,\n}\n\n\nexport class Atlas{\n    library:Library;\n    sprites:Array<Sprite>;\n    image:HTMLImageElement;\n\n    app:string;\n    version:string;\n    imagePath:string;\n    format:string;\n    size:{w:Float, h:Float};\n    resolution:string;\n    pixelData: ReturnType<Scene['getPixelData']>;\n\n    \n    constructor(props:AtlasProps){\n        this.sprites = [];\n        this.library = props.library;\n        this.image = props.image;\n        this.app = props.app;\n        this.version = props.version;\n        this.imagePath = props.imagePath;\n        this.format = props.format;\n        this.size = props.size;\n        this.resolution = props.resolution;\n        this.pixelData = props.pixelData;\n\n        // this.library.scene.getPixelData(this.image) // TODO: Determine is this should be a lazy operation\n    }\n\n\n\n    getPixel(x:Float, y:Float){\n        x = Math.floor(x)\n        y = Math.floor(y)\n        \n        let i = x + (y*this.pixelData.imageData.width)\n\n        const data = this.pixelData.imageData.data\n        return [\n            data[(i*4) + 0],\n            data[(i*4) + 1],\n            data[(i*4) + 2],\n            data[(i*4) + 3],\n        ]\n    }\n\n\n}\n", "import { AnimationJson } from \"./AnimationJson\";\n\nconst keys:Record<string, string> = {\n    // Fix inconsistent names\n\n    // spritemap.json\n    SPRITE: \"sprite\",\n    SPRITES: \"sprites\",\n    ATLAS: \"atlas\",\n\n    // Animation.json\n    ANIMATION: \"animation\",\n    ATLAS_SPRITE_instance: \"atlasSpriteInstance\",\n    DecomposedMatrix: \"decomposedMatrix\",\n    Frames: \"frames\",\n    framerate: \"frameRate\",\n    Instance_Name: \"instanceName\",\n    Layer_name: \"layerName\",\n    Layer_type: \"layerType\",\n    Clipped_by: \"clippedBy\",\n    LAYERS: \"layers\",\n    Matrix3D: \"matrix3D\",\n    Position: \"position\",\n    Rotation: \"rotation\",\n    Scaling: \"scaling\",\n    SYMBOL_DICTIONARY: \"symbolDictionary\",\n    SYMBOL_Instance: \"symbolInstance\",\n    SYMBOL_name: \"symbolName\",\n    Symbols: \"symbols\",\n    TIMELINE: \"timeline\",\n\n\n    // Filter\n    GradientEntries: \"gradientEntries\",\n\n    // Color\n    RedMultiplier: 'redMultiplier',\n    AlphaOffset: 'alphaOffset',\n\n     // Animation.json optimised\n     AN: \"animation\",\n     AM: \"alphaMultiplier\",\n     ASI: \"atlasSpriteInstance\",\n     BM: \"bitmap\",\n     C: \"color\",\n     DU: \"duration\",\n     E: \"elements\",\n     FF: \"firstFrame\",\n     FR: \"frames\",\n     FRT: \"frameRate\",\n     I: \"index\",\n     IN: \"instanceName\",\n     L: \"layers\",\n     LN: \"layerName\",\n     LP: \"loop\",\n     M3D: \"matrix3D\",\n     MD: \"metadata\",\n     M: \"mode\",\n     N: \"name\",\n     POS: \"position\",\n     S: \"symbols\",\n     SD: \"symbolDictionary\",\n     SI: \"symbolInstance\",\n     SN: \"symbolName\",\n     ST: \"symbolType\",\n     TL: \"timeline\",\n     TRP: \"transformationPoint\",\n};\n\n\nfunction normaliseKey(key:string){\n    return keys[key] || key;\n}\n\n\n\n// AnimateCC exports wildy inconsistent JSON. Normalise the\n// fields to make it easier to work with\nexport function normaliseJson(data:any):any{\n    if(typeof data == \"string\" || typeof data == \"number\") return data\n    switch(typeof data){\n        case \"string\": return data;\n        case \"number\": return data;\n        case \"boolean\": return data;\n        case \"object\":\n            if(Array.isArray(data)){\n                return (data as Array<any>).map(normaliseJson);\n            }else{\n                var result:any = {};\n                Object.keys(data).forEach(key => result[normaliseKey(key)] = normaliseJson(data[key]));\n                return result;\n            }\n        case \"bigint\": throw(\"Not supported\");\n        case \"function\": throw(\"Not supported\");\n        case \"symbol\": throw(\"Not supported\");\n        case \"undefined\": throw(\"Not supported\");\n        default: throw(\"Unsupported\")\n    }\n}\n", "export const createImage:(src:string)=>Promise<HTMLImageElement> = (src:string) =>\n    new Promise(resolve => {\n        const img = new Image();\n        img.src = src;\n        img.onload = () => resolve(img);\n        img.onerror = () => { throw(\"Image did not load: \" + img.src) }\n    });", "import { AnimationJson } from \"./json/AnimationJson\";\nimport { Clip, ClipProps } from \"./Clip\";\nimport { Vec2 } from \"./geom/Vec2\";\nimport { InstanceProps } from \"./Instance\";\nimport { Sprite, SpriteProps } from \"./Sprite\";\nimport { Atlas, AtlasProps } from \"./Atlas\";\nimport { normaliseJson } from \"./json/utilJson\";\nimport { Scene } from \"./Scene\";\nimport { Matrix } from \"./geom/Matrix\";\nimport { createImage } from \"./util/createImage\";\n\n\nexport class Library{\n\n    name:string;\n    path:string;\n    clips:Array<Clip> = [];\n    clipsByName:Record<string, Clip> = {};\n    spritesByName:Record<string, Sprite> = {};\n    atlases:Array<Atlas> = [];\n    atlasesBySpriteName:Record<string, Atlas> = {}\n    scene:Scene;\n    \n    \n    constructor(name:string, path:string, scene:Scene){\n        this.name = name;\n        this.path = path;\n        this.atlases = [];\n        this.scene = scene;\n    }\n\n\n    symbol(name:string){\n        if(this.clipsByName[name]) return this.clipsByName[name]\n        if(this.spritesByName[name]) return this.spritesByName[name]\n        throw(\"Cannot find symbol: \" + name + \" for library: \" + this.path);\n    }\n\n\n    createAtlas(props:Omit<AtlasProps, 'library'|'pixelData'>, pixelData:ReturnType<Scene['getPixelData']>){\n        const atlas = new Atlas({...props, library:this, pixelData});\n        this.atlases.push(atlas);\n        return atlas;\n    }\n\n\n    createSprite(atlas:Atlas, props:Omit<SpriteProps, 'atlas'>){\n        const sprite = new Sprite({...props, atlas:atlas})\n        atlas.sprites.push(sprite);\n        this.spritesByName[sprite.name] = sprite;\n        this.atlasesBySpriteName[sprite.name] = atlas;\n        return sprite;\n    }\n\n\n    createClip(props:Omit<ClipProps, 'library'>){\n        const clip = new Clip({...props, library:this});\n        this.clips.push(clip)\n        this.clipsByName[clip.name] = clip\n        return clip;\n    }\n\n\n    public async loadData(){\n        const animJsonPath = this.path + \"/Animation.json\";\n        const animFetchResult = await fetch(animJsonPath);\n        const dataRaw:AnimationJson = await animFetchResult.json();\n        const data = normaliseJson(dataRaw) as AnimationJson;\n        const spriteNames:Array<string> = [];\n\n        // Clip\n        for(const symbolData of data.symbolDictionary.symbols){\n            const clip = this.createClip({\n                name: symbolData.symbolName,\n            })\n\n            // Layer\n            for(let l=symbolData.timeline.layers.length-1; l>=0; l--){\n                const layerData = symbolData.timeline.layers[l]\n                const layer = clip.createLayer({\n                    name: layerData.layerName,\n                    type: layerData.layerType || 'Normal',\n                    clippedBy: layerData.clippedBy || null,\n                })\n\n                // Frame\n                for(const frameData of layerData.frames){\n                    const frame = layer.createFrame({\n                        name: \"\"+frameData.index,\n                        totalFrames: frameData.duration,\n                        labelName: frameData.name,\n                        index: frameData.index,\n                    })\n\n                    // Element\n                    for(const elemInstanceData of  frameData.elements){\n                        if(\"symbolInstance\" in elemInstanceData){\n                            const elemData = elemInstanceData.symbolInstance;\n                            const m = elemData.matrix3D;\n\n                            const instanceProps:Omit<InstanceProps, 'totalFrames'>  = {\n                                frame,\n                                name: frame.name,\n                                filters: elemData.filters || null,\n                                matrix: 'm00' in m ? new Matrix(m.m00, m.m01, m.m02, m.m03,\n                                                                    m.m10, m.m11, m.m12, m.m13,\n                                                                    m.m20, m.m21, m.m22, m.m23,\n                                                                    m.m30, m.m31, m.m32, m.m33)\n                                                     : new Matrix(m[ 0], m[ 1], m[ 2], m[ 3],\n                                                                    m[ 4], m[ 5], m[ 6], m[ 7],\n                                                                    m[ 8], m[ 9], m[10], m[11],\n                                                                    m[12], m[13], m[14], m[15]),\n                                itemName: elemData.symbolName,\n                                color: elemData.color || null,\n                                //position: new Vec3(elemData.decomposedMatrix.position),\n                                //scale: new Vec3(elemData.decomposedMatrix.scaling),\n                                //rotation: new Vec3(elemData.decomposedMatrix.rotation),\n                            }\n\n                            const clipInstance = frame.createClipInstance({\n                                ...instanceProps,\n                                transformationPoint: new Vec2(elemData.transformationPoint),\n                                behaviour: elemData.symbolType == \"graphic\"\n                                         ? { type: 'graphic', loop: elemData.loop, firstFrame: elemData.firstFrame}\n                                         : { type: 'movieclip' }\n                            })\n                        }else{\n                            const elemData = elemInstanceData.atlasSpriteInstance;\n                            const m = elemData.matrix3D;\n\n                            const spriteInstance = frame.createSpriteInstance({\n                                name: frame.name,\n                                filters: elemData.filters || null,\n                                color: null,\n                                matrix: 'm00' in m ? new Matrix(m.m00, m.m01, m.m02, m.m03,\n                                                                    m.m10, m.m11, m.m12, m.m13,\n                                                                    m.m20, m.m21, m.m22, m.m23,\n                                                                    m.m30, m.m31, m.m32, m.m33)\n                                                     : new Matrix(m[ 0], m[ 1], m[ 2], m[ 3],\n                                                                    m[ 4], m[ 5], m[ 6], m[ 7],\n                                                                    m[ 8], m[ 9], m[10], m[11],\n                                                                    m[12], m[13], m[14], m[15]),\n                                itemName: elemData.name,\n                                //position: new Vec3(elemData.decomposedMatrix.position),\n                                //scale: new Vec3(elemData.decomposedMatrix.scaling),\n                                //rotation: new Vec3(elemData.decomposedMatrix.rotation),\n                            })\n\n                            if(spriteNames.indexOf(spriteInstance.itemName)==-1) spriteNames.push(spriteInstance.itemName)\n                        }\n                    }\n                }\n            }\n        };\n\n        // Sprites\n        let pendingAtlasIndex = 1;\n        for(const spriteName of spriteNames){\n            if(this.atlasesBySpriteName[spriteName]==null){\n                const spriteJsonPath = this.path + `/spritemap${pendingAtlasIndex}.json`;\n                const altasFetch = await fetch(spriteJsonPath);\n                const dataRaw:SpriteMapJson = await altasFetch.json();\n                const data = normaliseJson(dataRaw) as SpriteMapJson;\n\n                const imagePath = this.path + `/spritemap${pendingAtlasIndex}.png`;\n                const image = await createImage(imagePath) // TODO: This will impact load times. Find a way to make this load parallel. Workers?\n\n                \n                const atlas = this.createAtlas({\n                    image,\n                    app: data.meta.app,\n                    version: data.meta.version,\n                    imagePath: data.meta.image,\n                    format: data.meta.format,\n                    size: data.meta.size,\n                    resolution: data.meta.resolution ,\n                }, this.scene.getPixelData(image),)\n                for(const spriteSpriteData of data.atlas.sprites){\n                    const spriteData = spriteSpriteData.sprite;\n                    const sprite = this.createSprite(atlas, {\n                        name: spriteData.name,\n                        x: spriteData.x,\n                        y: spriteData.y,\n                        width: spriteData.w,\n                        height: spriteData.h,\n                        rotated: spriteData.rotated,\n                    })\n                    this.atlasesBySpriteName[sprite.name] = atlas;\n                }\n\n\n                pendingAtlasIndex++;\n            }\n        }\n\n    }\n\n\n}\n", "import { Drawable } from \"./Drawable\";\nimport { Library } from \"./Library\";\n\n\nexport class Scene{\n\n    draw: (item:Drawable, frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void) => void\n    drawImage: (image:HTMLImageElement, sx:number, sy:number, sw:number, sh:number, rx:number, ry:number, rw:number, rh:number) => void\n    pixelData:Record<string, { ctx:CanvasRenderingContext2D, imageData:ImageData, image:HTMLImageElement }>\n\n\n    constructor(){\n        this.draw = null! // OVERRIDE THIS IN THE BASE CLASS!\n        this.drawImage = null!\n        this.pixelData = {}\n    }\n\n\n    get mouseX():number{\n        throw(\"Override mouseX in base class\")\n    }\n\n\n    get mouseY():number{\n        throw(\"Override mouseY in base class\")\n    }\n\n  \n    createLibrary(name:string, path:string){\n        const library = new Library(name, path, this);\n        return library;\n    }\n\n\n    getPixelData(image:HTMLImageElement){\n        if(image.complete==false) throw(\"Image has not loaded!\")\n\n        const canvas = document.createElement('canvas')\n        canvas.width = image.width\n        canvas.height = image.height\n        const ctx = document.createElement('canvas').getContext('2d')!\n        ctx.drawImage(image, 0, 0);\n\n        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)\n\n        return {\n            ctx,\n            imageData,\n            image,\n        }\n    }\n\n\n}", "import { Scene } from \"./core/Scene\"\nimport { ClipInstance } from \"./core/ClipInstance\";\nimport { Drawable } from \"./core/Drawable\"\nimport { Frame } from \"./core/Frame\";\nimport { Instance } from \"./core/Instance\"\nimport { FilterDropShadow, FilterType } from \"./core/json/AnimationJson\";\nimport { Layer } from \"./core/Layer\";\nimport { Sprite } from \"./core/Sprite\"\nimport { SpriteInstance } from \"./core/SpriteInstance\";\nimport { modWrap } from \"./core/util/math\";\n\n\n// This is all of the library's rendering code required to draw into a canvas 2d context.\n// This could easily be ported to any immediate mode rendering context, ie WebGL.\n// This could also be ported to scene graph based libraries like PixiJS, or event the DOM,\n// with a few modification to faciliate mapping to a scene graph.\nexport class Canvas2dScene extends Scene{\n    \n    canvas:HTMLCanvasElement\n    stack:CanvasRenderingContext2D[]\n    pool:CanvasRenderingContext2D[]\n\n    //imageData:Record<string, \n\n    private _mouseX:number;\n    private _mouseY:number;\n\n\n    constructor(ctx:CanvasRenderingContext2D){\n        super();\n        this.canvas = ctx.canvas\n        this.stack = [ctx]\n        this.pool = [];\n\n        this._mouseX = -1;\n        this._mouseY = -1;\n        ctx.canvas.addEventListener('mousemove', this.onMouseMove.bind(this))\n    }\n\n\n    onMouseMove(e:MouseEvent){\n        const rect = this.canvas.getBoundingClientRect()\n        const scaleX = this.canvas.width / rect.width\n        const scaleY = this.canvas.height / rect.height\n        this._mouseX = (e.clientX - rect.left) * scaleX\n        this._mouseY = (e.clientY - rect.top) * scaleY\n    }\n\n\n    get mouseX(){\n        return this._mouseX\n    }\n\n\n    get mouseY(){\n        return this._mouseY\n    }\n\n\n    getLocal(x:number, y:number){\n        const point = new DOMPoint(x, y)\n        const matrix = this.ctx.getTransform()\n        const imatrix = matrix.inverse()\n        return point.matrixTransform(imatrix)\n    }\n\n\n    get ctx(){\n        return this.stack[this.stack.length-1]\n    }\n\n\n    pushRenderTarget(){\n        const ctx = this.pool.length==0 ? document.createElement('canvas').getContext('2d')! : this.pool.pop()!\n        ctx.canvas.width = this.ctx.canvas.width\n        ctx.canvas.height = this.ctx.canvas.height\n        ctx.setTransform(this.ctx.getTransform())\n        this.stack.push(ctx)\n    }\n\n\n    popRenderTarget(){\n        if(this.stack.length<=1) throw(\"Cannot pop stack\")\n        const ctx = this.stack.pop()!;\n        this.ctx.save();\n        this.ctx.resetTransform()\n        this.ctx.drawImage(ctx!.canvas, 0, 0);\n        this.ctx.restore();\n        this.pool.push(ctx)\n    }\n\n\n    draw = (item:Drawable, frame:Float, lerp?:boolean, callback?:(item:Drawable, frame:Float, lerp?:boolean)=>void) => {\n        if(item instanceof Layer){\n           if(item.type=='Clipper'){\n           }else if(item.clippedBy){\n                const clipLayer = item.clip.layersByName[item.clippedBy]\n                this.pushRenderTarget()\n                clipLayer.draw(frame, lerp, callback)\n                this.ctx.globalCompositeOperation = 'source-in'\n                if(callback) callback(item, frame, lerp)\n                else item.draw(frame, lerp, callback)\n                this.popRenderTarget()\n            }else{\n                if(callback) callback(item, frame, lerp)\n                else item.draw(frame, lerp, callback)\n            }\n        }else if(item instanceof Instance){\n            this.ctx.save()\n            this.transformInstance(item, frame, lerp)\n            const didPushContext = this.handleFilters(item, frame, lerp)\n            this.handleColor(item, frame, lerp)\n            if(callback) callback(item, frame, lerp)\n            else item.draw(frame, lerp, callback)\n            if(didPushContext) this.popRenderTarget()\n            this.ctx.restore()\n        }else if(item instanceof Sprite){\n            if(callback) callback(item, frame, lerp)\n            else item.draw(frame, lerp, callback)\n        }else{\n            if(callback) callback(item, frame, lerp)\n            else item.draw(frame, lerp, callback)\n        }\n    }\n\n\n\n    drawImage = (image:HTMLImageElement, sx:number, sy:number, sw:number, sh:number, rx:number, ry:number, rw:number, rh:number) => {\n        this.ctx.drawImage(image, sx, sy, sw, sh, rx, ry, rw, rh)\n    }\n\n    \n    private handleColor(item:Instance, frame:Float, lerp?:boolean){\n        // TODO: Handle lerp on color\n        if(item.color?.mode == 'CA' || item.color?.mode == 'Alpha' || item.color?.mode == 'Advanced' || item.color?.mode == 'AD') this.ctx.globalAlpha *= item.color.alphaMultiplier;\n    }\n\n\n    private handleFilters(item:Instance, frame:Float, lerp?:boolean){\n        // TODO: Handle lerp on filters\n        if(item.filters){\n            for(let k of Object.keys(item.filters)){\n                const key = k as FilterType;\n                if(key=='DropShadowFilter'){\n                    const filter = item.filters[key] as FilterDropShadow;\n                    this.pushDropShadow(\n                        filter.color + (Math.round(filter.strength*255)).toString(16),\n                        filter.blurX,\n                        Math.cos(filter.angle*Math.PI/180) * filter.distance,\n                        Math.sin(filter.angle*Math.PI/180) * filter.distance,\n                    )\n                    return true;\n                }\n            }\n        }\n    }\n\n\n    pushDropShadow(color:string, blur:number, offsetX:Float=0, offsetY:Float=0){\n        this.ctx.save();\n        this.ctx.shadowColor = color;\n        this.ctx.shadowBlur = blur;\n        this.ctx.shadowOffsetX = offsetX;\n        this.ctx.shadowOffsetY = offsetY;\n        this.pushRenderTarget();\n    }\n\n\n    popDropShadow(){\n        this.popRenderTarget();\n        this.ctx.restore()\n    }\n\n\n    private transformInstance(item:Instance, frame:Float, lerp?:boolean){\n        if(lerp && item.next){\n            const t = (modWrap(frame, item.totalFrames)-item.index) / item.frame.totalFrames;\n            const m1 = item.matrix\n            const m2 = item.next.matrix \n            \n            this.ctx.transform(\n                m1._00 + (m2._00-m1._00)*t,\n                m1._01 + (m2._01-m1._01)*t,\n                m1._10 + (m2._10-m1._10)*t,\n                m1._11 + (m2._11-m1._11)*t,\n                m1._30 + (m2._30-m1._30)*t,\n                m1._31 + (m2._31-m1._31)*t,\n            )\n        }else{\n            this.ctx.transform(item.matrix._00, item.matrix._01, item.matrix._10, item.matrix._11, item.matrix._30, item.matrix._31)\n        }\n    }\n    \n}", "import { setupCanvas } from \"./example-utils\";\nimport { Canvas2dScene } from \"../Canvas2dScene\";\n\n// Set up canvas\nconst canvas = document.getElementById(\"canvas\") as HTMLCanvasElement\nconst ctx2d = canvas.getContext('2d')!\nvar dpr = setupCanvas(canvas) // Device pixel ratio\n\n// Set up animation context and animation libraries\nconst scene = new Canvas2dScene(ctx2d)\nconst testLibrary = scene.createLibrary('test', './test')\n\n\nasync function init(){\n    await testLibrary.loadData();\n    update();\n}\n\n\nlet frame = 0;\n    \nfunction update(){\n    scene.ctx.clearRect(0, 0, canvas.width, canvas.height)\n\n    scene.ctx.save();\n    \n        scene.ctx.translate(canvas.width/2, canvas.height/2)\n        scene.ctx.scale(dpr, dpr)\n\n        testLibrary.symbol(\"Scene\").draw(frame)\n\n    scene.ctx.restore()\n    \n    frame+=1;\n    requestAnimationFrame(update)\n}\n\ninit();\n"],
  "mappings": "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",
  "names": []
}
